#lang pie-a-let-mode


;; Exercise Set 0
;; Jacob Adley

;NOTE:
;the assignment is labeled by EXERCISE #
;there are also some PROPERTY # but you can ignore these


#|
Choose Your Own Adventure... er... Assignment!
* Due Friday April 20th 

* Because this assignment is unique, it will not be the "lowest
  exercise set grade" that is dropped from your score at the end
  of the course

* What you should aim for: 

** 8 problems/exercises that are interesting/non-trivial in some
   way along with solutions (you can do more if you wish, but I
   think 8 is a good goal to have)

** Problems such as "Claim and prove that 9 is a perfect square"
   can be helpful in clarifying what something means, but such
   problems do not count towards the required 8
   problems/exercises

** 4 of the problems/exercises should require an
   interesting/non-trivial lemma -- that lemma should
   either be a previous problem or some new/unproven
   thing. Please CLEARLY indicate these problems
   in your assignment, stating WHAT LEMMA/PROOF they
   depend on.

*** Example indicators for when a lemma might be useful: 

**** Are you doing induction within an induction? Yuck! How about
     you pull out that inner induction out and phrase it as a
     lemma?

**** Are your writing the same few steps over and over in a proof?
     Would having a "helper function" (I.e. a lemma) make the proof
     much clearer?

**** etc 

* For an example of what your assignment could look like, see
  exercise sets 5 and 6. Those each have about a dozen problems,
  about half of which the solution reasonably depends on some
  helper function/lemma/etc.

* You're more than welcome to start the assignment with a
  "Prelude" which includes a bunch of proofs we've already
  done. These cannot count as exercises or the required
  "interesting lemmas", but they can be useful in helping you
  more easily come up with interesting exercises.

* Be creative! Have some fun! Put some effort into it, but don't
  work yourself to death! Ask/discuss on piazza if you're
  struggling to come up with ideas.|#


;; SUPPLIED CODE -------------------------------------------------------------

(claim succ (-> Nat Nat))
(define succ (λ (x) (add1 x)))


(claim + (-> Nat Nat Nat))
(define + (λ (x y) (iter-Nat x y succ)))


(claim * (-> Nat Nat Nat))
(define * (λ (x y) (iter-Nat x 0 (+ y))))

(claim pow
  (-> Nat Nat
    Nat))
(define pow
  (λ (x n)
    (rec-Nat n
      1
      (λ (k pow-k)
        (* x pow-k)))))

(claim double
  (-> Nat Nat))
(define double
  (λ (n)
    (iter-Nat n 0 (+ 2))))


(claim Even (-> Nat U))
(define Even
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (double k)))))


(claim Odd (-> Nat U))
(define Odd
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (add1 (double k))))))


(claim +0-r
  (Π ([x Nat])
    (= Nat
       (+ x 0)
       x)))
(define +0-r
  (λ (x)
    (ind-Nat x
      (λ (x) (= Nat
               (+ x 0)
               x))
      (same 0)
      (λ (k IH)
        (cong IH succ)))))

(claim +0-l
  (Π ([x Nat])
    (= Nat
       (+ 0 x)
       x)))
(define +0-l
  (λ (x)
    (same x)))


(claim +-add1-l
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ (add1 n) m)
       (add1 (+ n m)))))
(define +-add1-l
  (λ (n m)
    (same (add1 (+ n m)))))


(claim +-add1-r
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ n (add1 m))
       (add1 (+ n m)))))
(define +-add1-r
  (λ (n m)
    (ind-Nat n
      (λ (?) (= Nat
               (+ ? (add1 m))
               (add1 (+ ? m))))
      (same (add1 m))
      (λ (k IH)
        (cong IH succ)))))


(claim *1-l
  (Π ([x Nat])
    (= Nat
       (* 1 x)
       x)))
(define *1-l
  (λ (x)
    (ind-Nat x
      (λ (x) (= Nat
               (* 1 x)
               x))
      (same 0)
      (λ (k IH)
        (cong IH succ)))))


(claim *1-r
  (Π ([x Nat])
    (= Nat
       (* x 1)
       x)))
(define *1-r
  (λ (x)
    (ind-Nat x
      (λ (x) (= Nat
               (* x 1)
               x))
      (same 0)
      (λ (k IH)
        (cong IH succ)))))


(claim *0-r
  (Π ([x Nat])
    (= Nat
       (* x 0)
       0)))
(define *0-r
  (λ (x)
    (ind-Nat x
      (λ (x) (= Nat
               (* x 0)
               0))
      (same 0)
      (λ (k k+0=k)
        k+0=k))))


(claim *0-l
  (Π ([x Nat])
    (= Nat
       (* 0 x)
       0)))
(define *0-l
  (λ (x)
    (same 0)))


(claim +-assoc
  (Π ([x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (+ (+ x y) z)
       (+ x (+ y z)))))
(define +-assoc
  (λ (x y z)
    (ind-Nat x
      (λ (?) (= Nat
               (+ (+ ? y) z)
               (+ ? (+ y z))))
      (same (+ y z))
      (λ (k IH)
        (cong IH succ)))))


(claim +-comm
  (Π ([n Nat]
      [m Nat])
    (= Nat (+ n m) (+ m n))))
(define +-comm
  (λ (n m)
    (ind-Nat n
      (λ (?) (= Nat (+ ? m) (+ m ?)))
      (symm (+0-r m))
      (λ (k IH)
        (equal Nat
          (add1 (+ k m))
          #:by (cong IH succ)
          (add1 (+ m k))
          #:by (symm (+-add1-r m k))
          (+ m (add1 k)))))))


(claim a+b+c=b+a+c
  (Π ([a Nat]
      [b Nat]
      [c Nat])
    (= Nat
       (+ a (+ b c))
       (+ b (+ a c)))))
(define a+b+c=b+a+c
  (λ (a b c)
    (equal Nat
      (+ a (+ b c))
      #:by (symm (+-assoc a b c))
      (+ (+ a b) c)
      #:by (cong (+-comm a b)
             (the (-> Nat Nat)
               (λ (x) (+ x c))))
      (+ (+ b a) c)
      #:by (+-assoc b a c)
      (+ b (+ a c)))))


(claim rotate+
  (Π ([w Nat]
      [x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (+ (+ w x) (+ y z))
       (+ (+ w y) (+ x z)))))
(define rotate+
  (λ (w x y z)
    (equal Nat
      (+ (+ w x) (+ y z))
      #:by (a+b+c=b+a+c (+ w x) y z)
      (+ y (+ (+ w x) z))
      #:by (cong (+-comm (+ w x) z) (+ y))
      (+ y (+ z (+ w x)))
      #:by (cong (a+b+c=b+a+c z w x) (+ y))
      (+ y (+ w (+ z x)))
      #:by (a+b+c=b+a+c y w (+ z x))
      (+ w (+ y (+ z x)))
      #:by (cong (+-comm z x)
             (the (-> Nat Nat)
               (λ (x) (+ w (+ y x)))))
      (+ w (+ y (+ x z)))
      #:by (symm (+-assoc w y (+ x z)))
      (+ (+ w y) (+ x z)))))


(claim *-add1-r
  (Π ([j Nat]
      [k Nat])
    (= Nat
       (+ j (* j k))
       (* j (add1 k)))))
(define *-add1-r
  (λ (j k)
    (ind-Nat j
      (λ (x) (= Nat
               (+ x (* x k))
               (* x (add1 k))))
      (same 0)
      (λ (x IH)
        (equal Nat
          (+ (add1 x) (* (add1 x) k))
          #:by (same (add1 (+ x (* (add1 x) k))))
          (add1 (+ x (* (add1 x) k)))
          #:by (same (add1 (+ x (+ k (* x k)))))
          (add1 (+ x (+ k (* x k))))
          #:by (cong (a+b+c=b+a+c x k (* x k)) succ)
          (add1 (+ k (+ x (* x k))))
          #:by (cong IH (the (-> Nat Nat) (λ (?) (add1 (+ k ?)))))
          (add1 (+ k (* x (add1 k))))
          #:by (same (+ (add1 k) (* x (add1 k))))
          (+ (add1 k) (* x (add1 k)))
          #:by (same (* (add1 x) (add1 k)))
          (* (add1 x) (add1 k)))))))



(claim *-comm
  (Π ([n Nat]
      [m Nat])
    (= Nat (* n m) (* m n))))
(define *-comm
  (λ (n m)
    (ind-Nat n
      (λ (x) (= Nat (* x m) (* m x)))
      (symm (*0-r m))
      (λ (x IH)
        (equal Nat
          (* (add1 x) m)
          #:by (same (+ m (* x m)))
          (+ m (* x m))
          #:by (cong IH (+ m))
          (+ m (* m x))
          #:by (*-add1-r m x)
          (* m (add1 x)))))))


(claim *-add1-l
  (Π ([j Nat]
      [k Nat])
    (= Nat
       (+ k (* j k))
       (* (add1 j) k))))
(define *-add1-l
  (λ (j k)
    (equal Nat
      (+ k (* j k))
      #:by (replace (*-comm j k)
             (λ (?) (= Nat
                      (+ k (* j k))
                      (+ k ?)))
             (same (+ k (* j k))))
      (+ k (* k j))
      #:by (*-add1-r k j)
      (* k (add1 j))
      #:by (*-comm k (add1 j))
      (* (add1 j) k))))


(claim *-distr
  (Π ([l Nat]
      [m Nat]
      [n Nat])
    (= Nat
       (* l (+ m n))
       (+ (* l m) (* l n)))))
(define *-distr
  (λ (l m n)
    (ind-Nat l
      (λ (x) (= Nat
               (* x (+ m n))
               (+ (* x m) (* x n))))
      (same 0)
      (λ (k almostProof)
        (let ([IH (the (= Nat
                         (* k (+ m n))
                         (+ (* k m) (* k n)))
                    almostProof)])
          (equal Nat
                 (* (add1 k) (+ m n))
                 #:by (same (+ (+ m n) (* k (+ m n))))
                 (+ (+ m n) (* k (+ m n)))
                 #:by (cong IH (+ (+ m n)))
                 (+ (+ m n) (+ (* k m) (* k n)))
                 #:by (rotate+ m n (* k m) (* k n))
                 (+ (+ m (* k m)) (+ n (* k n)))
                 #:by (same (+ (* (add1 k) m) (* (add1 k) n)))
                 (+ (* (add1 k) m) (* (add1 k) n))))))))



(claim *-assoc
  (Π ([x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (* (* x y) z)
       (* x (* y z)))))
(define *-assoc
  (λ (x y z)
    (ind-Nat x
      (λ (x) (= Nat
               (* (* x y) z)
               (* x (* y z))))
      (same 0)
      (λ (k IH)
        (let ([IH (the (= Nat
                         (* (* k y) z)
                         (* k (* y z)))
                    IH)])
          (equal Nat
                 (* (* (add1 k) y) z)
                 #:by (replace (symm (*-add1-l k y))
                        (λ (?) (= Nat
                                 (* (* (add1 k) y) z)
                                 (* ? z)))
                        (same (* (* (add1 k) y) z)))
                 (* (+ y (* k y)) z)
                 #:by (*-comm (+ y (* k y)) z)
                 (* z (+ y (* k y)))
                 #:by (*-distr z y (* k y))
                 (+ (* z y) (* z (* k y)))
                 #:by (replace (*-comm z (* k y))
                        (λ (?) (= Nat
                                 (+ (* z y) (* z (* k y)))
                                 (+ (* z y) ?)))
                        (same (+ (* z y) (* z (* k y)))))
                 (+ (* z y) (* (* k y) z))
                 #:by (replace IH
                        (λ (?) (= Nat
                                 (+ (* z y) (* (* k y) z))
                                 (+ (* z y) ?)))
                        (same (+ (* z y) (* (* k y) z))))
                 (+ (* z y) (* k (* y z)))
                 #:by (replace (*-comm z y)
                        (λ (?) (= Nat
                                 (+ (* z y) (* k (* y z)))
                                 (+ ? (* k (* y z)))))
                        (same (+ (* z y) (* k (* y z)))))
                 (+ (* y z) (* k (* y z)))
                 #:by (symm (*-add1-l k (* y z)))
                 (* (add1 k) (* y z))))))))



(claim n+n=2n
  (Π ([n Nat])
    (= Nat
       (+ n n)
       (* 2 n))))
(define n+n=2n
  (λ (n)
    (ind-Nat n
      (λ (?) (= Nat
               (+ ? ?)
               (* 2 ?)))
      (same 0)
      (λ (k k+k=2k)
        (equal Nat
          (+ (add1 k) (add1 k))
          #:by (+-add1-r (add1 k) k)
          (add1 (+ (add1 k) k))
          #:by (cong (+-add1-l k k) succ)
          (add1 (add1 (+ k k)))
          #:by (cong k+k=2k (the (-> Nat Nat) (λ (?) (add1 (add1 ?)))))
          (add1 (add1 (* 2 k)))
          #:by (same (+ 2 (* 2 k)))
          (+ 2 (* 2 k))
          #:by (*-add1-r 2 k)
          (* 2 (add1 k)))))))



(claim rotate*
  (Π ([w Nat]
      [x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (* (* w x) (* y z))
       (* (* w y) (* x z)))))
(define rotate*
  (λ (w x y z)
    (equal Nat
      (* (* w x) (* y z))
      #:by (*-assoc w x (* y z))
      (* w (* x (* y z)))
      #:by (cong (*-comm x (* y z)) (* w))
      (* w (* (* y z) x))
      #:by (cong (*-assoc y z x) (* w))
      (* w (* y (* z x)))
      #:by (symm (*-assoc w y (* z x)))
      (* (* w y) (* z x))
      #:by (cong (*-comm z x) (* (* w y)))
      (* (* w y) (* x z)))))



(claim pointwise-vec-app
  (Π ([A U]
      [B U]
      [n Nat])
    (-> (Vec (-> A B) n) (Vec A n)
        (Vec B n))))
(define pointwise-vec-app
  (λ (A B)
    (λ (n)
      (λ (vec-fns)
        (ind-Vec n vec-fns
          (λ (k) (λ (vec-fns) (-> (Vec A k) (Vec B k))))
          (λ (_) vecnil)
          (λ (k fn vec-fns IH)
            (λ (vec-as)
              (vec:: (fn (head vec-as)) (IH (tail vec-as))))))))))


(check-same (Vec Nat 4)
  (vec:: 42 (vec:: 42 (vec:: 42 (vec:: 42 vecnil))))
  (pointwise-vec-app Nat Nat 4
    (vec:: (+ 2) (vec:: (* 2) (vec:: (+ 0) (vec:: (* 1) vecnil))))
    (vec:: 40 (vec:: 21 (vec:: 42 (vec:: 42 vecnil))))))


;; What should we be able to conclude if
;; we know that i = j?
;;
;;                  j            j
;;               | zero    | (add1 j-1)
;;  --------------------------------------
;; i  zero       | Trivial | Absurd 
;; --------------------------------------
;; i  (add1 i-1) | Absurd  | (= Nat i-1 j-1)


;; here is the above _claim_ as a type:

(claim =consequence
  (-> Nat Nat U))
(define =consequence
  (λ (i j)
    (which-Nat i
      (which-Nat j   Trivial (λ (j-1) Absurd))
      (λ (i-1)
        (which-Nat j Absurd  (λ (j-1) (= Nat i-1 j-1)))))))



(claim =consequence-same
  (Π ([n Nat]) (=consequence n n)))
(define =consequence-same
  (λ (n)
    (ind-Nat n
      (λ (n) (=consequence n n))
      sole
      (λ (k k=conseq)
        (same k)))))



(claim use-Nat=
  (Π ([i Nat]
      [j Nat])
    (-> (= Nat i j)
      (=consequence i j))))
(define use-Nat=
  (λ (i j i=j)
    (replace i=j
      (λ (hole) (=consequence i hole))
      (=consequence-same i))))


(claim dbl-distr-+
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ (double n) (double m))
       (double (+ n m)))))
(define dbl-distr-+
  (λ (n m)
    (ind-Nat n
      (λ (x) (= Nat
               (+ (double x) (double m))
               (double (+ x m))))
      (same (double m))
      (λ (x IH)
        (cong IH (+ 2))))))



(claim odd+even=odd
  (Π ([x Nat]
      [y Nat]
      [x-odd  (Odd x)]
      [y-even (Even y)])
    (Odd (+ x y))))
(define odd+even=odd
  (λ (x y)
    (λ (x-odd y-even)
      (let ([x/2         (car x-odd)]
            [x=1+dbl-x/2 (cdr x-odd)]
            [y/2         (car y-even)]
            [y=dbl-y/2   (cdr y-even)])
        (cons
         (+ x/2 y/2)
         (equal Nat
           (+ x y)
           #:by (replace x=1+dbl-x/2
                  (λ (?) (= Nat
                           (+ x y)
                           (+ ? y)))
                  (same (+ x y)))
           (+ (add1 (double x/2)) y)
           #:by (replace y=dbl-y/2
                  (λ (?) (= Nat
                           (+ (add1 (double x/2)) y)
                           (+ (add1 (double x/2)) ?)))
                  (same (+ (add1 (double x/2)) y)))
           (+ (add1 (double x/2)) (double y/2))
           #:by (same (add1 (+ (double x/2) (double y/2))))
           (add1 (+ (double x/2) (double y/2)))
           #:by (cong (dbl-distr-+ x/2 y/2) succ)
           (add1 (double (+ x/2 y/2)))))))))

;; START -------------------------------------------------------------


;; PART A -------------------------------------------------------------
#|

this is what I originally tried to prove, then changed thm1's claim to assume lemma
I failed when trying to prove the lemma, that if x+y is odd then either x is odd
and y is even or the opposite, but I got stuck and don't even think it's possible with my
current approach, stuck even at the base case

(claim lemma
  (Π ([x Nat]
      [y Nat]
      [x+y-odd (Odd (+ x y))])
    (Either (Σ ([x-odd  (Odd x)])  (Even y))
            (Σ ([x-even (Even x)]) (Odd y)))))
(define lemma
  (λ (x y)
    (λ (x+y-odd)
      (let ([x+y/2           (the Nat
                               (car x+y-odd))]
            [x+y=1+dbl-x+y/2 (the (= Nat
                                    (+ x y)
                                    (add1 (double x+y/2)))
                               (cdr x+y-odd))])
        (ind-Nat x
          (λ (x) (Either (Σ ([x-odd  (Odd x)])  (Even y))
                         (Σ ([x-even (Even x)]) (Odd y))))
          (right (cons
                   (cons zero (same 0))
                   (cons x+y/2 (equal Nat
                                 y
                                 #:by (same y)
                                 (+ 0 y)
                                 #:by TODO
                                 (+ x y)
                                 #:by x+y=1+dbl-x+y/2
                                 (add1 (double x+y/2))))))
          (λ (k IH)
            (let ([IH (the (Either (Σ ([k-odd  (Odd k)])  (Even y))
                                   (Σ ([k-even (Even k)]) (Odd y)))
                        IH)])
              (ind-Either IH
                (λ (_) (Either (Σ ([k-odd  (Odd (add1 k))])  (Even y))
                               (Σ ([k-even (Even (add1 k))]) (Odd y))))
                (λ (pair-k-odd-y-even) TODO)
                (λ (pair-k-even-y-odd) TODO)))))))))


(claim thm1
  (Π ([x Nat]
      [y Nat])
    (-> (Odd (+ x y))
      (Odd (+ (* (+ x y) (+ x y))
             (* x y))))))
(define thm1
  (λ (x y)
    (λ (x+y-odd)
      (ind-Either (lemma x y x+y-odd)
        (λ (_) (Odd (+ (* (+ x y) (+ x y)) (* x y))))
        (λ (xo-ye) (let ([x-odd (the (Odd x) (car xo-ye))]
                         [y-even (the (Even y) (cdr xo-ye))])
                     (odd+even=odd
                      (* (+ x y) (+ x y))
                      (* x y)
                      (odd*odd=odd (+ x y) (+ x y) x+y-odd x+y-odd)
                      (odd*even=even x y x-odd y-even))))
        (λ (xe-yo) (let ([x-even (the (Even x) (car xe-yo))]
                         [y-odd (the (Odd y) (cdr xe-yo))])
                     (odd+even=odd
                      (* (+ x y) (+ x y))
                      (* x y)
                      (odd*odd=odd (+ x y) (+ x y) x+y-odd x+y-odd)
                      (even*odd=even x y x-even y-odd))))))))

|#

;;EXERCISE 1 -- FOIL
;no lemmas
(claim foil
  (Π ([a Nat]
      [b Nat]
      [c Nat]
      [d Nat])
    (= Nat
       (* (+ a b) (+ c d))
       (+ (* a c) (+ (* a d) (+ (* b c) (* b d)))))))
(define foil
  (λ (a b c d)
    (equal Nat
      (* (+ a b) (+ c d))
      #:by (*-distr (+ a b) c d)
      (+ (* (+ a b) c) (* (+ a b) d))
      #:by (cong (*-comm (+ a b) c) (the (-> Nat Nat) (λ (?) (+ ? (* (+ a b) d)))))
      (+ (* c (+ a b)) (* (+ a b) d))
      #:by (cong (*-comm (+ a b) d) (the (-> Nat Nat) (λ (?) (+ (* c (+ a b)) ?))))
      (+ (* c (+ a b)) (* d (+ a b)))
      #:by (cong (*-distr c a b) (the (-> Nat Nat) (λ (?) (+ ? (* d (+ a b))))))
      (+ (+ (* c a) (* c b)) (* d (+ a b)))
      #:by (cong (*-distr d a b) (the (-> Nat Nat) (λ (?) (+ (+ (* c a) (* c b)) ?))))
      (+ (+ (* c a) (* c b)) (+ (* d a) (* d b)))
      #:by (cong (*-comm c a) (the (-> Nat Nat) (λ (?) (+ (+ ? (* c b)) (+ (* d a) (* d b))))))
      (+ (+ (* a c) (* c b)) (+ (* d a) (* d b)))
      #:by (cong (*-comm c b) (the (-> Nat Nat) (λ (?) (+ (+ (* a c) ?) (+ (* d a) (* d b))))))
      (+ (+ (* a c) (* b c)) (+ (* d a) (* d b)))
      #:by (cong (*-comm d a) (the (-> Nat Nat) (λ (?) (+ (+ (* a c) (* b c)) (+ ? (* d b))))))
      (+ (+ (* a c) (* b c)) (+ (* a d) (* d b)))
      #:by (cong (*-comm d b) (the (-> Nat Nat) (λ (?) (+ (+ (* a c) (* b c)) (+ (* a d) ?)))))
      (+ (+ (* a c) (* b c)) (+ (* a d) (* b d)))
      #:by (rotate+ (* a c) (* b c) (* a d) (* b d))
      (+ (+ (* a c) (* a d)) (+ (* b c) (* b d)))
      #:by (+-assoc (* a c) (* a d) (+ (* b c) (* b d)))
      (+ (* a c) (+ (* a d) (+ (* b c) (* b d)))))))


(claim *2=dbl
  (Π ([x Nat])
    (= Nat
       (* 2 x)
       (double x))))
(define *2=dbl
  (λ (x)
    (ind-Nat x
      (λ (x) (= Nat
               (* 2 x)
               (double x)))
      (same 0)
      (λ (k IH)
        (let ([IH (the (= Nat
                         (* 2 k)
                         (double k)) IH)])
          (equal Nat
                 (* 2 (add1 k))
                 #:by (same (* 2 (+ 1 k)))
                 (* 2 (+ 1 k))
                 #:by (*-distr 2 1 k)
                 (+ (* 2 1) (* 2 k))
                 #:by (same (add1 (add1 (* 2 k))))
                 (add1 (add1 (* 2 k)))
                 #:by (replace IH
                        (λ (?) (= Nat
                                 (add1 (add1 (* 2 k)))
                                 (add1 (add1 ?))))
                        (same (add1 (add1 (* 2 k)))))
                 (add1 (add1 (double k)))
                 #:by (same (double (add1 k)))
                 (double (add1 k))))))))


(claim dbl-abstr-*
  (Π ([x Nat]
      [y Nat])
    (= Nat
       (* (double x) y)
       (double (* x y)))))
(define dbl-abstr-*
  (λ (x y)
    (ind-Nat x
      (λ (x) (= Nat
               (* (double x) y)
               (double (* x y))))
      (same 0)
      (λ (k IH)
        (let ([IH (the (= Nat
                         (* (double k) y)
                         (double (* k y))) IH)])
          (equal Nat
                 (* (double (succ k)) y)
                 #:by (same (* (succ (succ (double k))) y))
                 (* (succ (succ (double k))) y)
                 #:by (same (* (+ 2 (double k)) y))
                 (* (+ 2 (double k)) y)
                 #:by (replace (symm (+0-r y))
                        (λ (?) (= Nat
                                 (* (+ 2 (double k)) y)
                                 (* (+ 2 (double k)) ?)))
                        (same (* (+ 2 (double k)) y)))
                 (* (+ 2 (double k)) (+ y 0))
                 #:by (foil 2 (double k) y 0)
                 (+ (* 2 y) (+ (* 2 0) (+ (* (double k) y) (* (double k) 0))))
                 #:by (same (+ (* 2 y) (+ (* (double k) y) (* (double k) 0))))
                 (+ (* 2 y) (+ (* (double k) y) (* (double k) 0)))
                 #:by (replace (*0-r (double k))
                        (λ (?) (= Nat
                                 (+ (* 2 y) (+ (* (double k) y) (* (double k) 0)))
                                 (+ (* 2 y) (+ (* (double k) y) ?))))
                        (same (+ (* 2 y) (+ (* (double k) y) (* (double k) 0)))))
                 (+ (* 2 y) (+ (* (double k) y) 0))
                 #:by (replace (+0-r (* (double k) y))
                        (λ (?) (= Nat
                                 (+ (* 2 y) (+ (* (double k) y) 0))
                                 (+ (* 2 y) ?)))
                        (same (+ (* 2 y) (+ (* (double k) y) 0))))
                 (+ (* 2 y) (* (double k) y))
                 #:by (replace IH
                        (λ (?) (= Nat
                                 (+ (* 2 y) (* (double k) y))
                                 (+ (* 2 y) ?)))
                        (same (+ (* 2 y) (* (double k) y))))
                 (+ (* 2 y) (double (* k y)))
                 #:by (replace (*2=dbl y)
                        (λ (?) (= Nat
                                 (+ (* 2 y) (double (* k y)))
                                 (+ ? (double (* k y)))))
                        (same (+ (* 2 y) (double (* k y)))))
                 (+ (double y) (double (* k y)))
                 #:by (dbl-distr-+ y (* k y))
                 (double (+ y (* k y)))
                 #:by (same (double (* (succ k) y)))
                 (double (* (succ k) y))))))))
  
;;exercise 2 - odd * odd = odd
;lemmas: dbl-abstr-*, *2=double
(claim odd*odd=odd
  (Π ([x Nat]
      [y Nat]
      [x-odd (Odd x)]
      [y-odd (Odd y)])
    (Odd (* x y))))
(define odd*odd=odd
  (λ (x y)
    (λ (x-odd y-odd)
      (let ([x/2           (car x-odd)]
            [x=1+dbl-x/2   (cdr x-odd)]
            [y/2           (car y-odd)]
            [y=1+dbl-y/2   (cdr y-odd)])
        
        (cons (+ y/2 (+ x/2 (* x/2 (double y/2))))
              (equal Nat
                (* x y)
                #:by (replace x=1+dbl-x/2
                       (λ (?) (= Nat
                                (* x y)
                                (* ? y)))
                       (same (* x y)))
                (* (add1 (double x/2)) y)
                #:by (replace y=1+dbl-y/2
                       (λ (?) (= Nat
                                (* (add1 (double x/2)) y)
                                (* (add1 (double x/2)) ?)))
                       (same (* (add1 (double x/2)) y)))
                (* (add1 (double x/2)) (add1 (double y/2)))
                #:by (same (* (+ 1 (double x/2)) (+ 1 (double y/2))))
                (* (+ 1 (double x/2)) (+ 1 (double y/2)))
                #:by (foil 1 (double x/2) 1 (double y/2))
                (+ (* 1 1) (+ (* 1 (double y/2)) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))
                #:by (same (add1 (+ (* 1 (double y/2)) (+ (* (double x/2) 1) (* (double x/2) (double y/2))))))
                (add1 (+ (* 1 (double y/2)) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))
                #:by (replace (*1-l (double y/2))
                       (λ (?) (= Nat
                                (add1 (+ (* 1 (double y/2)) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))
                                (add1 (+ ? (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))))
                       (same (add1 (+ (* 1 (double y/2)) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))))
                (add1 (+ (double y/2) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))
                #:by (replace (*1-r (double x/2))
                       (λ (?) (= Nat
                                (add1 (+ (double y/2) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))
                                (add1 (+ (double y/2) (+ ? (* (double x/2) (double y/2)))))))
                       (same (add1 (+ (double y/2) (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))))
                (add1 (+ (double y/2) (+ (double x/2) (* (double x/2) (double y/2)))))
                #:by (replace (dbl-abstr-* x/2 (double y/2))
                       (λ (?) (= Nat
                                (add1 (+ (double y/2) (+ (double x/2) (* (double x/2) (double y/2)))))
                                (add1 (+ (double y/2) (+ (double x/2) ?)))))
                       (same (add1 (+ (double y/2) (+ (double x/2) (* (double x/2) (double y/2)))))))
                (add1 (+ (double y/2) (+ (double x/2) (double (* x/2 (double y/2))))))
                #:by (replace (dbl-distr-+ x/2 (* x/2 (double y/2)))
                       (λ (?) (= Nat
                                (add1 (+ (double y/2) (+ (double x/2) (double (* x/2 (double y/2))))))
                                (add1 (+ (double y/2) ?))))
                       (same (add1 (+ (double y/2) (+ (double x/2) (double (* x/2 (double y/2))))))))
                (add1 (+ (double y/2) (double (+ x/2 (* x/2 (double y/2))))))
                #:by (cong (dbl-distr-+ y/2 (+ x/2 (* x/2 (double y/2)))) succ)
                (add1 (double (+ y/2 (+ x/2 (* x/2 (double y/2))))))))))))

;;EXERCISE 3 -- even * odd = even AND odd * even = even
;no lemmas (re-used from previous)
(claim even*odd=even
  (Π ([x Nat]
      [y Nat]
      [x-even (Even x)]
      [y-odd (Odd y)])
    (Even (* x y))))
(define even*odd=even
  (λ (x y)
    (λ (x-even y-odd)
      (let ([x/2         (car x-even)]
            [x=dbl-x/2   (cdr x-even)]
            [y/2         (car y-odd)]
            [y=1+dbl-y/2 (cdr y-odd)])
        (cons (+ x/2 (* x/2 (double y/2)))
              (equal Nat
                (* x y)
                #:by (replace x=dbl-x/2
                       (λ (?) (= Nat
                                (* x y)
                                (* ? y)))
                       (same (* x y)))
                (* (double x/2) y)
                #:by (replace y=1+dbl-y/2
                       (λ (?) (= Nat
                                (* (double x/2) y)
                                (* (double x/2) ?)))
                       (same (* (double x/2) y)))
                (* (double x/2) (add1 (double y/2)))
                #:by (same (* (double x/2) (+ 1 (double y/2))))
                (* (double x/2) (+ 1 (double y/2)))
                #:by (*-distr (double x/2) 1 (double y/2))
                (+ (* (double x/2) 1) (* (double x/2) (double y/2)))
                #:by (replace (*1-r (double x/2))
                       (λ (?) (= Nat
                                (+ (* (double x/2) 1) (* (double x/2) (double y/2)))
                                (+ ? (* (double x/2) (double y/2)))))
                       (same (+ (* (double x/2) 1) (* (double x/2) (double y/2)))))
                (+ (double x/2) (* (double x/2) (double y/2)))
                #:by (replace (dbl-abstr-* x/2 (double y/2))
                       (λ (?) (= Nat
                                (+ (double x/2) (* (double x/2) (double y/2)))
                                (+ (double x/2) ?)))
                       (same (+ (double x/2) (* (double x/2) (double y/2)))))
                (+ (double x/2) (double (* x/2 (double y/2))))
                #:by (dbl-distr-+ x/2 (* x/2 (double y/2)))
                (double (+ x/2 (* x/2 (double y/2))))))))))


(claim odd*even=even
  (Π ([x Nat]
      [y Nat]
      [x-odd (Odd x)]
      [y-even (Even y)])
    (Even (* x y))))
(define odd*even=even
  (λ (x y)
    (λ (x-odd y-even)
      (let ([x/2         (car x-odd)]
            [x=1+dbl-x/2   (cdr x-odd)]
            [y/2         (car y-even)]
            [y=dbl-y/2 (cdr y-even)])
        (cons (+ y/2 (* y/2 (double x/2)))
              (equal Nat
                (* x y)
                #:by (replace y=dbl-y/2
                       (λ (?) (= Nat
                                (* x y)
                                (* x ?)))
                       (same (* x y)))
                (* x (double y/2))
                #:by (replace x=1+dbl-x/2
                       (λ (?) (= Nat
                                (* x (double y/2))
                                (* ? (double y/2))))
                       (same (* x (double y/2))))
                (* (add1 (double x/2)) (double y/2))
                #:by (same (* (+ 1 (double x/2)) (double y/2)))
                (* (+ 1 (double x/2)) (double y/2))
                #:by (*-comm (+ 1 (double x/2)) (double y/2))
                (* (double y/2) (+ 1 (double x/2)))
                #:by (*-distr (double y/2) 1 (double x/2))
                (+ (* (double y/2) 1) (* (double y/2) (double x/2)))
                #:by (replace (*1-r (double y/2))
                       (λ (?) (= Nat
                                (+ (* (double y/2) 1) (* (double y/2) (double x/2)))
                                (+ ? (* (double y/2) (double x/2)))))
                       (same (+ (* (double y/2) 1) (* (double y/2) (double x/2)))))
                (+ (double y/2) (* (double y/2) (double x/2)))
                #:by (replace (dbl-abstr-* y/2 (double x/2))
                       (λ (?) (= Nat
                                (+ (double y/2) (* (double y/2) (double x/2)))
                                (+ (double y/2) ?)))
                       (same (+ (double y/2) (* (double y/2) (double x/2)))))
                (+ (double y/2) (double (* y/2 (double x/2))))
                #:by (dbl-distr-+ y/2 (* y/2 (double x/2)))
                (double (+ y/2 (* y/2 (double x/2))))))))))






;;EXERCISE 4 -- prove this theorem: if x+y is odd, then (x+y)^2 + xy is odd
;no lemmas: requires exercises 1-3
(claim thm1
  (Π ([x Nat]
      [y Nat])
    (-> (Odd (+ x y)) (Either (Σ ([x-odd  (Odd x)])  (Even y))
                        (Σ ([x-even (Even x)]) (Odd y)))
      (Odd (+ (* (+ x y) (+ x y))
             (* x y))))))
(define thm1
  (λ (x y)
    (λ (x+y-odd H)
      (ind-Either H
        (λ (_) (Odd (+ (* (+ x y) (+ x y)) (* x y))))
        (λ (xo-ye) (let ([x-odd (the (Odd x) (car xo-ye))]
                         [y-even (the (Even y) (cdr xo-ye))])
                     (odd+even=odd
                      (* (+ x y) (+ x y))
                      (* x y)
                      (odd*odd=odd (+ x y) (+ x y) x+y-odd x+y-odd)
                      (odd*even=even x y x-odd y-even))))
        (λ (xe-yo) (let ([x-even (the (Even x) (car xe-yo))]
                         [y-odd (the (Odd y) (cdr xe-yo))])
                     (odd+even=odd
                      (* (+ x y) (+ x y))
                      (* x y)
                      (odd*odd=odd (+ x y) (+ x y) x+y-odd x+y-odd)
                      (even*odd=even x y x-even y-odd))))))))


;;---------------------------------------------------------------
;SQUARES
;;---------------------------------------------------------------
;Given the following definition of a square, complete the following
;proofs about squares
;EXERCISE 5
;write some definitions for Square numbers and pythagorean triplets, to be used in later exercises

(claim Square (-> Nat U))
(define Square
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (* k k)))))

(claim pythagorean-triplet
  (-> Nat Nat
    U))
(define pythagorean-triplet
  (λ (a b)
    (Σ ([c Nat])
      (= Nat
         (+ (* a a) (* b b))
         (* c c)))))

;;----------------------------------------
;;EXERCISE 6
;lemma: property1-lemma
;;PROPERTY 1
;;square of a nat n is equal to the sum of first n odd nats
;;1*1 = 1
;;2*2 = 1 + 3
;;3*3 = 1 + 3 + 5
;;4*4 = 1 + 3 + 5 + 7
;given:
(claim sum-first-n-odd-nats
  (-> Nat Nat))
(define sum-first-n-odd-nats
  (λ (n)
    (rec-Nat n
      0
      (λ (k sum-of-first-k-odd-nats)
        (+ (add1 (* 2 k)) sum-of-first-k-odd-nats)))))


(claim property1-lemma
  (Π ([n Nat])
    (= Nat
       (* (add1 n) (add1 n))
       (+ (add1 (* 2 n)) (* n n)))))
(define property1-lemma
  (λ (n)
    (equal Nat
      (* (add1 n) (add1 n))
      #:by (same (* (+ 1 n) (+ 1 n)))
      (* (+ 1 n) (+ 1 n))
      #:by (foil 1 n 1 n)
      (+ (* 1 1) (+ (* 1 n) (+ (* n 1) (* n n))))
      #:by (same (+ 1 (+ (* 1 n) (+ (* n 1) (* n n)))))
      (+ 1 (+ (* 1 n) (+ (* n 1) (* n n))))
      #:by (replace (*1-l n)
             (λ (?) (= Nat
                      (+ 1 (+ (* 1 n) (+ (* n 1) (* n n))))
                      (+ 1 (+ ? (+ (* n 1) (* n n))))))
             (same (+ 1 (+ (* 1 n) (+ (* n 1) (* n n))))))
      (+ 1 (+ n (+ (* n 1) (* n n))))
      #:by (replace (*1-r n)
             (λ (?) (= Nat
                      (+ 1 (+ n (+ (* n 1) (* n n))))
                      (+ 1 (+ n (+ ? (* n n))))))
             (same (+ 1 (+ n (+ (* n 1) (* n n))))))
      (+ 1 (+ n (+ n (* n n))))
      #:by (replace (symm (+-assoc n n (* n n)))
             (λ (?) (= Nat
                      (+ 1 (+ n (+ n (* n n))))
                      (+ 1 ?)))
             (same (+ 1 (+ n (+ n (* n n))))))
      (+ 1 (+ (+ n n) (* n n)))
      #:by (replace (n+n=2n n)
             (λ (?) (= Nat
                      (+ 1 (+ (+ n n) (* n n)))
                      (+ 1 (+ ? (* n n)))))
             (same (+ 1 (+ (+ n n) (* n n)))))
      (+ 1 (+ (* 2 n) (* n n)))
      #:by (same (add1 (+ (* 2 n) (* n n))))
      (add1 (+ (* 2 n) (* n n)))
      #:by (symm (+-add1-l (* 2 n) (* n n)))
      (+ (add1 (* 2 n)) (* n n)))))


(claim property1
  (Π ([n Nat])
    (= Nat
       (* n n)
       (sum-first-n-odd-nats n))))
(define property1
  (λ (n)
    (ind-Nat n
      (λ (?) (= Nat
               (* ? ?)
               (sum-first-n-odd-nats ?)))
      (same 0)
      (λ (k k*k=sum-odds-k)
        (equal Nat
          (* (add1 k) (add1 k))
          #:by (property1-lemma k)
          (+ (add1 (* 2 k)) (* k k))
          #:by (cong k*k=sum-odds-k (+ (add1 (* 2 k))))
          (+ (add1 (* 2 k)) (sum-first-n-odd-nats k))
          #:by (same (sum-first-n-odd-nats (add1 k)))
          (sum-first-n-odd-nats (add1 k)))))))

;--------------------------------------------------------------------------------------
;PROPERTY 2

;;A number having 2, 3, 7, 8 at unit's place is not a perfect square

;--------------------------------------------------------------------------------------
;PROPERTY 3
;;square of even number is even, square of odd numbers is odd

;proved earlier

;--------------------------------------------------------------------------------------
;PROPERTY 4
;;square of a natural number other than 1 is either a multiple of 3 or exceeds a multiple of 3 by 1

;--------------------------------------------------------------------------------------
;PROPERTY 5
;;the unit's digit of the square of a nat is the unit's digit of the square of the digit at unit's place of given nat

;--------------------------------------------------------------------------------------
;PROPERTY 6
;;n natural numbers p and q such that p*p = 2(q*q)

;--------------------------------------------------------------------------------------
;PROPERTY 7
;;for every nat n, (n+1)^2 - n^2 = (n+1) + n

;--------------------------------------------------------------------------------------
;;EXERCISE 7
;no lemmas: requires exercise 5
;PROPERTY  8
;;for any nat n, (2sqrt(n+1), n+1 - 1, n+1 + 1) is a pythagorean triplet
(claim property8
  (Π ([n Nat]
      [n+1-square (Square (add1 n))])
    (pythagorean-triplet (* 2 (car n+1-square)) n)))
(define property8
  (λ (n n+1-square)
    (let ([sqrt-n+1       (car n+1-square)]
          [n+1=sqrt-n+1^2 (cdr n+1-square)])
      (cons (add1 (add1 n))
            (equal Nat
              (+ (* (* 2 sqrt-n+1) (* 2 sqrt-n+1)) (* n n))
              #:by (replace (symm (n+n=2n sqrt-n+1))
                     (λ (?) (= Nat
                              (+ (* (* 2 sqrt-n+1) (* 2 sqrt-n+1)) (* n n))
                              (+ (* ? ?) (* n n))))
                     (same (+ (* (* 2 sqrt-n+1) (* 2 sqrt-n+1)) (* n n))))
              (+ (* (+ sqrt-n+1 sqrt-n+1) (+ sqrt-n+1 sqrt-n+1)) (* n n))
              #:by (replace (foil sqrt-n+1 sqrt-n+1 sqrt-n+1 sqrt-n+1)
                     (λ (?) (= Nat
                              (+ (* (+ sqrt-n+1 sqrt-n+1) (+ sqrt-n+1 sqrt-n+1)) (* n n))
                              (+ ? (* n n))))
                     (same (+ (* (+ sqrt-n+1 sqrt-n+1) (+ sqrt-n+1 sqrt-n+1)) (* n n))))
              (+ (+ (* sqrt-n+1 sqrt-n+1) (+ (* sqrt-n+1 sqrt-n+1) (+ (* sqrt-n+1 sqrt-n+1) (* sqrt-n+1 sqrt-n+1)))) (* n n))
              #:by (replace (symm n+1=sqrt-n+1^2)
                     (λ (?) (= Nat
                              (+ (+ (* sqrt-n+1 sqrt-n+1) (+ (* sqrt-n+1 sqrt-n+1) (+ (* sqrt-n+1 sqrt-n+1) (* sqrt-n+1 sqrt-n+1)))) (* n n))
                              (+ (+ ? (+ ? (+ ? ?))) (* n n))))
                     (same (+ (+ (* sqrt-n+1 sqrt-n+1) (+ (* sqrt-n+1 sqrt-n+1) (+ (* sqrt-n+1 sqrt-n+1) (* sqrt-n+1 sqrt-n+1)))) (* n n))))
              (+ (+ (add1 n) (+ (add1 n) (+ (add1 n) (add1 n)))) (* n n))
              #:by (replace (symm (+-assoc (add1 n) (add1 n) (+ (add1 n) (add1 n))))
                     (λ (?) (= Nat
                              (+ (+ (add1 n) (+ (add1 n) (+ (add1 n) (add1 n)))) (* n n))
                              (+ ? (* n n))))
                     (same (+ (+ (add1 n) (+ (add1 n) (+ (add1 n) (add1 n)))) (* n n))))
              (+ (+ (+ (add1 n) (add1 n)) (+ (add1 n) (add1 n))) (* n n))
              #:by (replace (+-add1-r (add1 n) n)
                     (λ (?) (= Nat
                              (+ (+ (+ (add1 n) (add1 n)) (+ (add1 n) (add1 n))) (* n n))
                              (+ (+ ? ?) (* n n))))
                     (same (+ (+ (+ (add1 n) (add1 n)) (+ (add1 n) (add1 n))) (* n n))))
              (+ (+ (add1 (+ (add1 n) n)) (add1 (+ (add1 n) n))) (* n n))
              #:by (replace (+-add1-l n n)
                     (λ (?) (= Nat
                              (+ (+ (add1 (+ (add1 n) n)) (add1 (+ (add1 n) n))) (* n n))
                              (+ (+ (add1 ?) (add1 ?)) (* n n))))
                     (same (+ (+ (add1 (+ (add1 n) n)) (add1 (+ (add1 n) n))) (* n n))))
              (+ (+ (add1 (add1 (+ n n))) (add1 (add1 (+ n n)))) (* n n))
              #:by (replace (n+n=2n n)
                     (λ (?) (= Nat
                              (+ (+ (add1 (add1 (+ n n))) (add1 (add1 (+ n n)))) (* n n))
                              (+ (+ (add1 (add1 ?)) (add1 (add1 ?))) (* n n))))
                     (same (+ (+ (add1 (add1 (+ n n))) (add1 (add1 (+ n n)))) (* n n))))
              (+ (+ (add1 (add1 (* 2 n))) (add1 (add1 (* 2 n)))) (* n n))
              #:by (same (+ (+ (+ 2 (* 2 n)) (+ 2 (* 2 n))) (* n n)))
              (+ (+ (+ 2 (* 2 n)) (+ 2 (* 2 n))) (* n n))
              #:by (replace (symm (+-assoc (+ 2 (* 2 n)) 2 (* 2 n)))
                     (λ (?) (= Nat
                              (+ (+ (+ 2 (* 2 n)) (+ 2 (* 2 n))) (* n n))
                              (+ ? (* n n))))
                     (same (+ (+ (+ 2 (* 2 n)) (+ 2 (* 2 n))) (* n n))))
              (+ (+ (+ (+ 2 (* 2 n)) 2) (* 2 n)) (* n n))
              #:by (replace (+-comm 2 (* 2 n))
                     (λ (?) (= Nat
                              (+ (+ (+ (+ 2 (* 2 n)) 2) (* 2 n)) (* n n))
                              (+ (+ (+ ? 2) (* 2 n)) (* n n))))
                     (same (+ (+ (+ (+ 2 (* 2 n)) 2) (* 2 n)) (* n n))))
              (+ (+ (+ (+ (* 2 n) 2) 2) (* 2 n)) (* n n))
              #:by (replace (+-assoc (* 2 n) 2 2)
                     (λ (?) (= Nat
                              (+ (+ (+ (+ (* 2 n) 2) 2) (* 2 n)) (* n n))
                              (+ (+ ? (* 2 n)) (* n n))))
                     (same (+ (+ (+ (+ (* 2 n) 2) 2) (* 2 n)) (* n n))))
              (+ (+ (+ (* 2 n) (+ 2 2)) (* 2 n)) (* n n))
              #:by (same (+ (+ (+ (* 2 n) 4) (* 2 n)) (* n n)))
              (+ (+ (+ (* 2 n) 4) (* 2 n)) (* n n))
              #:by (replace (+-comm (* 2 n) 4)
                     (λ (?) (= Nat
                              (+ (+ (+ (* 2 n) 4) (* 2 n)) (* n n))
                              (+ (+ ? (* 2 n)) (* n n))))
                     (same (+ (+ (+ (* 2 n) 4) (* 2 n)) (* n n))))
              (+ (+ (+ 4 (* 2 n)) (* 2 n)) (* n n))
              #:by (replace (+-assoc 4 (* 2 n) (* 2 n))
                     (λ (?) (= Nat
                              (+ (+ (+ 4 (* 2 n)) (* 2 n)) (* n n))
                              (+ ? (* n n))))
                     (same (+ (+ (+ 4 (* 2 n)) (* 2 n)) (* n n))))
              (+ (+ 4 (+ (* 2 n) (* 2 n))) (* n n))
              #:by (+-assoc 4 (+ (* 2 n) (* 2 n)) (* n n))
              (+ 4 (+ (+ (* 2 n) (* 2 n)) (* n n)))
              #:by (replace (+-assoc (* 2 n) (* 2 n) (* n n))
                     (λ (?) (= Nat
                              (+ 4 (+ (+ (* 2 n) (* 2 n)) (* n n)))
                              (+ 4 ?)))
                     (same (+ 4 (+ (+ (* 2 n) (* 2 n)) (* n n)))))
              (+ 4 (+ (* 2 n) (+ (* 2 n) (* n n))))
              #:by (replace (*-comm 2 n)
                     (λ (?) (= Nat
                              (+ 4 (+ (* 2 n) (+ (* 2 n) (* n n))))
                              (+ 4 (+ (* 2 n) (+ ? (* n n))))))
                     (same (+ 4 (+ (* 2 n) (+ (* 2 n) (* n n))))))
              (+ 4 (+ (* 2 n) (+ (* n 2) (* n n))))
              #:by (same (+ (* 2 2) (+ (* 2 n) (+ (* n 2) (* n n)))))
              (+ (* 2 2) (+ (* 2 n) (+ (* n 2) (* n n))))
              #:by (symm (foil 2 n 2 n))
              (* (+ 2 n) (+ 2 n))
              #:by (same (* (add1 (add1 n)) (add1 (add1 n))))
              (* (add1 (add1 n)) (add1 (add1 n))))))))

;--------------------------------------------------------------------------------------
;;EXERCISE 8
;PROPERTY 9
;product of 2 squares is a square
(claim a^2*b^2=ab^2
  (Π ([a Nat]
      [b Nat]
      [a-square (Square a)]
      [b-square (Square b)])
    (= Nat
       (* a b)
       (* (* (car a-square) (car b-square)) (* (car a-square) (car b-square))))))
(define a^2*b^2=ab^2
  (λ (a b)
    (λ (a-square b-square)
      (let ([sqrt-a    (car a-square)]
            [a=sqrt-a^2 (cdr a-square)]
            [sqrt-b    (car b-square)]
            [b=sqrt-b^2 (cdr b-square)])
        (equal Nat
               (* a b)
               #:by (replace a=sqrt-a^2
                      (λ (?) (= Nat
                               (* a b)
                               (* ? b)))
                      (same (* a b)))
               (* (* sqrt-a sqrt-a) b)
               #:by (replace b=sqrt-b^2
                      (λ (?) (= Nat
                               (* (* sqrt-a sqrt-a) b)
                               (* (* sqrt-a sqrt-a) ?)))
                      (same (* (* sqrt-a sqrt-a) b)))
               (* (* sqrt-a sqrt-a) (* sqrt-b sqrt-b))
               #:by (*-assoc sqrt-a sqrt-a (* sqrt-b sqrt-b))
               (* sqrt-a (* sqrt-a (* sqrt-b sqrt-b)))
               #:by (replace (*-comm sqrt-a (* sqrt-b sqrt-b))
                      (λ (?) (= Nat
                               (* sqrt-a (* sqrt-a (* sqrt-b sqrt-b)))
                               (* sqrt-a ?)))
                      (same (* sqrt-a (* sqrt-a (* sqrt-b sqrt-b)))))
               (* sqrt-a (* (* sqrt-b sqrt-b) sqrt-a))
               #:by (replace (*-assoc sqrt-b sqrt-b sqrt-a)
                      (λ (?) (= Nat
                               (* sqrt-a (* (* sqrt-b sqrt-b) sqrt-a))
                               (* sqrt-a ?)))
                      (same (* sqrt-a (* (* sqrt-b sqrt-b) sqrt-a))))
               (* sqrt-a (* sqrt-b (* sqrt-b sqrt-a)))
               #:by (replace (*-comm sqrt-b sqrt-a)
                      (λ (?) (= Nat
                               (* sqrt-a (* sqrt-b (* sqrt-b sqrt-a)))
                               (* sqrt-a (* sqrt-b ?))))
                      (same (* sqrt-a (* sqrt-b (* sqrt-b sqrt-a)))))
               (* sqrt-a (* sqrt-b (* sqrt-a sqrt-b)))
               #:by (symm (*-assoc sqrt-a sqrt-b (* sqrt-a sqrt-b)))
               (* (* sqrt-a sqrt-b) (* sqrt-a sqrt-b)))))))


;--------------------------------------------------------------------------------------
;;EXERCISE 9
;define what it means to be a multiple of 3 with remainder 0, 1, 2
(claim 3n
  (-> Nat U))
(define 3n
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (* 3 k)))))

(claim 3n+1
  (-> Nat U))
(define 3n+1
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (add1 (* 3 k))))))

(claim 3n+2
  (-> Nat U))
(define 3n+2
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (add1 (add1 (* 3 k)))))))

;EXERCISE 10 -- NOTE: I got stuck here, but it's still kinda cool
#|
why did I get suck?
I got stuck trying to prove that if a number is 3 times a number and it
is also three times some number +1 then I want to return an absurd
I think that I could have proved this with 3k and 3k+1 (i.e. the same number),
but since it was an arbitrary number (i.e. 3k and 3c+1) then I couldn't find
a way to prove it.
|#
;PROPERTY 10
;if n^2 is a multiple of 3, then n is a multiple of 3
;for all Nats n there exists a Nat k such that n is equal to either either 3k or 3k+1 or 3k+2
(claim 3nV3n+1V3n+2
  (Π ([n Nat])
    (Either
     (3n n)
     (Either
       (3n+1 n)
       (3n+2 n)))))
(define 3nV3n+1V3n+2
  (λ (n)
    (ind-Nat n
      (λ (n) (Either
               (3n n)
               (Either
                 (3n+1 n)
                 (3n+2 n))))
      (left (cons 0 (same 0)))
      (λ (k IH)
        (ind-Either IH
          (λ (_) (Either
                   (3n (add1 k))
                   (Either
                     (3n+1 (add1 k))
                     (3n+2 (add1 k)))))
          (λ (3n-k)
            (let ([k/3 (car 3n-k)]
                  [k=3*k/3 (cdr 3n-k)])
              (right (left (cons k/3 (cong k=3*k/3 succ))))))
          (λ (either-3n+1/2-k)
            (ind-Either either-3n+1/2-k
              (λ (_) (Either
                       (3n (add1 k))
                       (Either
                         (3n+1 (add1 k))
                         (3n+2 (add1 k)))))
              (λ (3n+1-k)
                (let ([k/3 (car 3n+1-k)]
                      [k=1+3*k/3 (cdr 3n+1-k)])
                  (right (right (cons k/3 (cong k=1+3*k/3 succ))))))
              (λ (3n+2-k)
                (let ([k/3 (car 3n+2-k)]
                      [k=2+3*k/3 (cdr 3n+2-k)])
                  (left (cons (add1 k/3)
                          (equal Nat
                            (add1 k)
                            #:by (cong k=2+3*k/3 succ)
                            (add1 (+ 2 (* 3 k/3)))
                            #:by (same (+ 3 (* 3 k/3)))
                            (+ 3 (* 3 k/3))
                            #:by (*-add1-r 3 k/3)
                            (* 3 (add1 k/3))))))))))))))

;not useful?
#;
#;
(claim n=1+n->absurd
  (Π ([n Nat])
    (-> (= Nat n (add1 n))
      Absurd)))
(define n=1+n->absurd
  (λ (n n=1+n)
    (use-Nat= n (add1 n) n=1+n)))


(claim 3n-and-3n+1->absurd
  (Π ([n Nat]
      [n-square (Square n)])
    (-> (3n n) (3n+1 n)
      Absurd)))
(define 3n-and-3n+1->absurd
  (λ (n n-square 3n-n 3n+1-n)
    (let ([sqrt-n              (car n-square)]
          [n=sqrt-n^2          (cdr n-square)]
          [n/3                 (car 3n-n)]
          [n=3*n/3             (cdr 3n-n)]
          [n/3-v2              (car 3n+1-n)]
          [n=1+3*n/3-v2        (cdr 3n+1-n)])
      (ind-Nat n/3
        (λ (?) Absurd)
        TODO
        TODO))))


(claim 3n-and-3sqrt-n+1->absurd
  (Π ([n Nat]
      [n-square (Square n)])
    (-> (3n n) (3n+1 (car n-square))
      Absurd)))
(define 3n-and-3sqrt-n+1->absurd
  (λ (n n-square 3n-n 3n+1-sqrt-n)
    (let ([sqrt-n              (car n-square)]
          [n=sqrt-n^2          (cdr n-square)]
          [n/3                 (car 3n-n)]
          [n=3*n/3             (cdr 3n-n)]
          [sqrt-n/3            (car 3n+1-sqrt-n)]
          [sqrt-n=1+3*sqrt-n/3 (cdr 3n+1-sqrt-n)])
      (3n-and-3n+1->absurd n n-square 3n-n
                                  (cons (+ (* 3 (* sqrt-n/3 sqrt-n/3)) (* 2 sqrt-n/3))
                                    (equal Nat
                                      n
                                      #:by n=sqrt-n^2
                                      (* sqrt-n sqrt-n)
                                      #:by (replace sqrt-n=1+3*sqrt-n/3
                                             (λ (?) (= Nat
                                                      (* sqrt-n sqrt-n)
                                                      (* ? ?)))
                                             (same (* sqrt-n sqrt-n)))
                                      (* (add1 (* 3 sqrt-n/3)) (add1 (* 3 sqrt-n/3)))
                                      #:by (same (* (+ 1 (* 3 sqrt-n/3)) (+ 1 (* 3 sqrt-n/3))))
                                      (* (+ 1 (* 3 sqrt-n/3)) (+ 1 (* 3 sqrt-n/3)))
                                      #:by (foil 1 (* 3 sqrt-n/3) 1 (* 3 sqrt-n/3))
                                      (+ (* 1 1) (+ (* 1 (* 3 sqrt-n/3)) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                      #:by (same (add1 (+ (* 1 (* 3 sqrt-n/3)) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3))))))
                                      (add1 (+ (* 1 (* 3 sqrt-n/3)) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                      #:by (replace (*1-l (* 3 sqrt-n/3))
                                             (λ (?)
                                               (= Nat
                                                 (add1 (+ (* 1 (* 3 sqrt-n/3)) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                                 (add1 (+ ? (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))))
                                             (same (add1 (+ (* 1 (* 3 sqrt-n/3)) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))))
                                      (add1 (+ (* 3 sqrt-n/3) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                      #:by (replace (*1-r (* 3 sqrt-n/3))
                                             (λ (?) (= Nat
                                                      (add1 (+ (* 3 sqrt-n/3) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                                      (add1 (+ (* 3 sqrt-n/3) (+ ? (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))))
                                             (same (add1 (+ (* 3 sqrt-n/3) (+ (* (* 3 sqrt-n/3) 1) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))))
                                      (add1 (+ (* 3 sqrt-n/3) (+ (* 3 sqrt-n/3) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                      #:by (replace (rotate* 3 sqrt-n/3 3 sqrt-n/3)
                                             (λ (?) (= Nat
                                                      (add1 (+ (* 3 sqrt-n/3) (+ (* 3 sqrt-n/3) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))
                                                      (add1 (+ (* 3 sqrt-n/3) (+ (* 3 sqrt-n/3) ?)))))
                                             (same (add1 (+ (* 3 sqrt-n/3) (+ (* 3 sqrt-n/3) (* (* 3 sqrt-n/3) (* 3 sqrt-n/3)))))))
                                      (add1 (+ (* 3 sqrt-n/3) (+ (* 3 sqrt-n/3) (* (* 3 3) (* sqrt-n/3 sqrt-n/3)))))
                                      #:by (cong (symm (+-assoc (* 3 sqrt-n/3) (* 3 sqrt-n/3) (* (* 3 3) (* sqrt-n/3 sqrt-n/3)))) succ)
                                      (add1 (+ (+ (* 3 sqrt-n/3) (* 3 sqrt-n/3)) (* (* 3 3) (* sqrt-n/3 sqrt-n/3))))
                                      #:by (cong (+-comm (+ (* 3 sqrt-n/3) (* 3 sqrt-n/3)) (* (* 3 3) (* sqrt-n/3 sqrt-n/3))) succ)
                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (+ (* 3 sqrt-n/3) (* 3 sqrt-n/3))))
                                      #:by (replace (symm (*-distr 3 sqrt-n/3 sqrt-n/3))
                                             (λ (?) (= Nat
                                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (+ (* 3 sqrt-n/3) (* 3 sqrt-n/3))))
                                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) ?))))
                                             (same (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (+ (* 3 sqrt-n/3) (* 3 sqrt-n/3))))))
                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 (+ sqrt-n/3 sqrt-n/3))))
                                      #:by (replace (n+n=2n sqrt-n/3)
                                             (λ (?) (= Nat
                                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 (+ sqrt-n/3 sqrt-n/3))))
                                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 ?)))))
                                             (same (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 (+ sqrt-n/3 sqrt-n/3))))))
                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 (* 2 sqrt-n/3))))
                                      #:by (replace (*-assoc 3 3 (* sqrt-n/3 sqrt-n/3))
                                             (λ (?) (= Nat
                                                      (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 (* 2 sqrt-n/3))))
                                                      (add1 (+ ? (* 3 (* 2 sqrt-n/3))))))
                                             (same (add1 (+ (* (* 3 3) (* sqrt-n/3 sqrt-n/3)) (* 3 (* 2 sqrt-n/3))))))
                                      (add1 (+ (* 3 (* 3 (* sqrt-n/3 sqrt-n/3))) (* 3 (* 2 sqrt-n/3))))
                                      #:by (symm (cong (*-distr 3 (* 3 (* sqrt-n/3 sqrt-n/3)) (* 2 sqrt-n/3)) succ))
                                      (add1 (* 3 (+ (* 3 (* sqrt-n/3 sqrt-n/3)) (* 2 sqrt-n/3))))))))))


;this will be very similar to above proof so I omitted it since I got stuck on the lemma it would require in the first place
(claim 3n-and-3sqrt-n+2->absurd
  (Π ([n Nat]
      [n-square (Square n)])
    (-> (3n n) (3n+2 (car n-square))
      Absurd)))
(define 3n-and-3sqrt-n+2->absurd
  TODO)


(claim 3n-n->3n-sqrt-n
  (Π ([n Nat]
      [n-square (Square n)]
      [3n-n (3n n)])
    (3n (car n-square))))
(define 3n-n->3n-sqrt-n
  (λ (n n-square 3n-n)
    (let ([sqrt-n     (car n-square)]
          [n=sqrt-n^2 (cdr n-square)]
          [n/3        (car 3n-n)]
          [n=3*n/3    (cdr 3n-n)])
      (ind-Either (3nV3n+1V3n+2 sqrt-n)
        (λ (_) (3n sqrt-n))
        (λ (3n-sqrt-n) 3n-sqrt-n)
        (λ (either:3n+1/2-sqrt-n)
          (ind-Either either:3n+1/2-sqrt-n
            (λ (_) (3n sqrt-n))
            (λ (3n+1-sqrt-n) (ind-Absurd (3n-and-3sqrt-n+1->absurd n n-square 3n-n 3n+1-sqrt-n)
                               (3n sqrt-n)))
            (λ (3n+2-sqrt-n) (ind-Absurd (3n-and-3sqrt-n+2->absurd n n-square 3n-n 3n+2-sqrt-n)
                               (3n sqrt-n)))))))))