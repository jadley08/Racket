#lang pie


;; Chapter 1-3 exercises
;; due 23 January by 3pm

; Jacob Adley


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 1
;; Define `intriguing-word` so that intriguing-word is an Atom.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim intriguing-word Atom)
(define intriguing-word 'eucatastrophe)

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 2
;; Define `lucky-num` so that lucky-num is a Nat.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim lucky-num Nat)
(define lucky-num 17)

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 3
;; Define `to-go-order` so that pickup-order is a (Pair Nat Atom).
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim to-go-order (Pair Nat Atom))
(define to-go-order (cons 4 'gyro))

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 4
;; Complete the definitions for `normal-atom`
;; and `abnormal-atom` such that:
;; 1. they are the same Atom
;; 2. normal-atom is in normal form
;; 3. abnormal-atom is _not_ in normal form
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim normal-atom Atom)
(define normal-atom 'ukulele)
(claim abnormal-atom Atom)
(define abnormal-atom (quote ukulele))
;; uncomment the following line once you have defined them:
;(check-same Atom normal-atom abnormal-atom)



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 6
;; Define `MyFirstType` so that MyFirstType is a type.
;; NOTE: `U` is the type that describes all types (except itself)
;; and is short for "the universe of types", so we have written
;; as a claim that T1 is a 'U' (i.e. is a type).
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim MyFirstType U)
(define MyFirstType Nat)


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 7
;; Define `my-thing-and-atom` so that my-thing-and-atom is
;; a (Pair MyFirstType U).
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim my-thing-and-Atom (Pair MyFirstType U))
(define my-thing-and-Atom (cons 17 Atom))


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 8
;; Define `was-is-das` so was-is-das is a (cdr was-is-das).
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim was-is-das (cdr my-thing-and-Atom))
(define was-is-das 'ukulele)


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 9
;; Complete the definitions for `NormalType` and
;; `NonNormalType` such that:
;; 1. they are the same type
;; 2. NormalType is in normal form
;; 3. NonNormalType is _not_ in normal form
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim NormalType U)
(define NormalType Nat)
(claim NonNormalType U)
(define NonNormalType (car (the (Pair U U) (cons Nat Nat))))
;; uncomment the following line once you have them:
(check-same U NormalType NonNormalType)



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 10
;; NOTE: `normal-pair` is in normal form.
;; Define `nonnormal-pair` such that
;; 1. nonnormal-pair is a value
;; 2. nonnormal-pair is not in normal form
;; 3. normal-pair is the same (Pair Atom Atom)
;;    as nonnormal-pair.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim normal-pair (Pair Atom Atom))
(define normal-pair (cons 'a 'd))
(claim nonnormal-pair (Pair Atom Atom))
(define nonnormal-pair (cons 'a (car (the (Pair Atom Atom) (cons 'd 'd)))))
;; uncomment the following line once you have defined nonnormal-pair
(check-same (Pair Atom Atom) normal-pair nonnormal-pair)





;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 11
;; Define and test `car-of-Nats` -- it should return the
;; first Nat in a pair of Nats.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim car-of-Nats
  (-> (Pair Nat Nat)
    Nat))
(define car-of-Nats
  (λ (p)
    (car p)))
; uncomment the tests once car-of-Nats is defined
(check-same Nat (car-of-Nats (cons 0 1)) 0)
(check-same Nat (car-of-Nats (cons 42 43)) 42)



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 12
;; Define and test `with-Nats`, a function that takes two
;; arguments:
;;   1. a binary function over Nats, and
;;   2. a pair of Nats.
;;
;; The result of with-Nats should be the result of applying
;; the function (argument 1) to the two Nats in the pair of
;; Nats (argument 2).
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim with-Nats
  (-> (-> Nat Nat
        Nat)
      (Pair Nat Nat)
    Nat))
(define with-Nats
  (λ (f p)
    (f (car p) (cdr p))))
; uncomment these after defining with-Nats
(check-same Nat (with-Nats (λ (n m) n) (cons 1 2)) 1)
(check-same Nat (with-Nats (λ (n m) (add1 m)) (cons 1 2)) 3)



;; `sub1` is a unary operator on Nats that,
;; when given input n, returns n-1. If n=0, simply return 0.
(claim sub1 (-> Nat Nat))
(define sub1 (λ (n) (which-Nat n
                      0
                      (λ (n-1) n-1))))
(check-same Nat (sub1 0) 0)
(check-same Nat (sub1 2) 1)

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 13
;; Define and test `at-least-two?`, it should take a Nat and
;; return the Atom 't if its argument has at least two add1s
;; at the top (i.e. if the Nat is >= 2), otherwise it should
;; return the Atom 'nil.
;; NOTE: the only Nat eliminator at-least-two? should
;;       use is `which-Nat`.
;;
;; For example:
;; (at-least-two? 0) ==> 'nil
;; (at-least-two? 1) ==> 'nil
;; (at-least-two? 2) ==> 't
;; ...
;; (at-least-two? 41) ==> 't
;; etc
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim at-least-two?
  (-> Nat
    Atom))
(define at-least-two?
  (λ (n) (which-Nat (sub1 n)
                    'nil
                    (λ (n-1) 't))))
; uncomment these tests after defining at-least-two?
(check-same Atom (at-least-two? 0) 'nil)
(check-same Atom (at-least-two? 1) 'nil)
(check-same Atom (at-least-two? 2) 't)
(check-same Atom (at-least-two? 41) 't)


;; Here is the definitions of addition for Nats:
(claim + (-> Nat Nat
           Nat))
(define + (λ (n m) (rec-Nat n
                     m
                     (λ (n-1 n-1+m) (add1 n-1+m)))))
(check-same Nat (+ 3 4) 7)
;; Here is the definitions of multiplication for Nats:
(claim * (-> Nat Nat
           Nat))
(define * (λ (n m) (rec-Nat n
                     0
                     (λ (n-1 n-1*m) (+ m n-1*m)))))
(check-same Nat (* 3 4) 12)

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 14
;; Define `expt` to be exponentiation of natural numbers.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim expt (-> Nat Nat Nat))
(define expt
  (λ (n m) (rec-Nat m
                    1
                    (λ (m-1 n^m-1) (* n n^m-1)))))
; uncomment these after defining expt
(check-same Nat (expt 2 0) 1)
(check-same Nat (expt 2 1) 2)
(check-same Nat (expt 2 2) 4)
(check-same Nat (expt 2 3) 8)



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 15 (Challenge)
;; Define and test `max`, a binary operator on natural numbers
;; that returns the larger of the two numbers it is given.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim max (-> Nat Nat Nat))
(define max
  (λ (n m) TODO))
; uncomment these after defining max
;(check-same Nat (max 0 1) 1)
;(check-same Nat (max 1 2) 2)
;(check-same Nat (max 2 1) 2)
;(check-same Nat (max 2 2) 2)
;(check-same Nat (max 3 2) 3)