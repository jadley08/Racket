#lang pie


;; Chapter 4,5, and 6 exercises
;; due 3pm Thursday, 8 Feb


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 1
;; What are the four judgments we discussed at the beginning
;; of class?
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; (List E)
; judgement 1:
;   if E is a type, then (List E) is a type
; judgement 2:
;   (List E) describes a (linked) list
;   whose elements are of type E
; judgement 3:
;   (List E) ::= nil | (:: E (List E))
; judgement 4:
;  if E is a type,
;    then nil is a (List E)
;  if
;    - E is a type
;    - e is an E
;    - es is a (List E)
;  then
;    (:: e es) is a (List E)


;; here is a function that adds two Nats
;; by eliminating the first:
(claim add (-> Nat Nat Nat))
(define add
  (λ (n m)
    (rec-Nat n
      m
      (λ (i-1 add-i-1-m)
        (add1 add-i-1-m)))))

(check-same Nat (add 3 4) 7)


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 2
;; Define and test `plus`, a (-> Nat Nat Nat) which, when
;; applied to two numbers, returns their sum by eliminating
;; the second Nat it is given with rec-Nat.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim plus
  (-> Nat Nat
    Nat))
(define plus
  (λ (n m)
    (rec-Nat m
             n
             (λ (i-1 add-i-1-n)
               (add1 add-i-1-n)))))

(check-same Nat (plus 0 42) 42)
(check-same Nat (plus 42 0) 42)
(check-same Nat (plus 3 4) 7)
(check-same Nat (plus 4 3) 7)

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 3
;; Are `add` and `plus` the same `(-> Nat Nat Nat)`?
;; Briefly describe why or why not?
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;No, although they are conceptually the same, when applied to
;only one argument the resulting function is not the same (-> Nat Nat).
;Additionally when called under a lambda: (λ (x) ((add/plus x) 1))
;do not produce the same thing. This is because if you eliminate
;the second argument like in plus, then when you only apply it to
;one argument then it simply puts that number in the base and you
;are still left with a rec-Nat.



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 4
;; Are `add` and `plus` "extensionally equal" functions?
;; Briefly describe why or why not?
;;
;; From Wikipedia: "In logic, extensionality, or extensional
;; equality, refers to principles that judge objects to be
;; equal if they have the same external properties. It stands
;; in contrast to the concept of intensionality, which is
;; concerned with whether the internal definitions of
;; objects are the same." (i.e. two functions are
;; extensionally equal iff they produce the same results when
;; provided the same inputs... so if these two functions
;; are both provided with two identical Nats, what can we
;; say about their outputs?)
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;Yes, if you provide the two functions with 2 Nats, they will
;produce the same thing because addition is communal and
;it doesn't matter which Nat we eliminate.









;; Here is a simple encoding of the booleans into Nat:
(claim Bool U)
(define Bool Nat)

(claim true Bool)
(define true 1)


(claim false Bool)
(define false 0)

(claim if (Π ([X U])
            (-> Bool X X X)))
(define if
  (λ (X question then-X else-X)
    (which-Nat question
      else-X
      (λ (_) then-X))))

(check-same Nat (if Nat true 42 0) 42)
(check-same Nat (if Nat false 42 0) 0)

;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 5
;; Finish the below commented out definition of `less-than` by
;; defining an appropriate base and step argument. `less-than`
;; should, when applied to two Nats, return true if the first
;; Nat is strictly less than the second Nat, otherwise it
;; returns false.
;;
;; NOTE: This function should not use any helper functions.
;;       If wish to define the base and/or step arguments
;;       to the rec-Nat separately because that is more clear
;;       to you that is fine, but each of those definitions
;;       should not rely on some other helper function you
;;       have defined that is doing the interesting work.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim less-than (-> Nat (-> Nat Bool)))
(define less-than
  (λ (n)
    (rec-Nat n
      (the (-> Nat Bool)
        (λ (m)
          (if Bool
            m
            true
            false)))
      (λ (i-1 less-than-i-1-else)
        (λ (m) (which-Nat m
                          false
                          (λ (m-1)
                              (less-than-i-1-else m-1))))))))

(check-same Nat (less-than 0 0) false)
(check-same Nat (less-than 0 1) true)
(check-same Nat (less-than 1 0) false)
(check-same Nat (less-than 10 6) false)
(check-same Nat (less-than 6 10) true)
(check-same Nat (less-than 10 10) false)
(check-same Nat (less-than 31 42) true)
(check-same Nat (less-than 42 31) false)
(check-same Nat (less-than 51 42) false)
(check-same Nat (less-than 42 52) true)








;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 6
;; Define and test a function `compose` that produces a
;; value that is an (-> A C) when given a (-> A B) and
;; a (-> B C)
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim compose (Π ([A U]
                   [B U]
                   [C U])
                 (-> (-> A B) (-> B C)
                   (-> A C))))

(define compose
  (λ (A B C)
    (λ (f1 f2)
      (λ (x) (f2 (f1 x))))))

(claim plus1 (-> Nat Nat))
(define plus1
  (λ (m) (add1 m)))

(check-same Nat ((compose Nat Nat Nat plus1 plus1) zero)
  (add1 (add1 zero)))



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 7
;; Define and test a function `sum-List` that finds the sum
;; of the entries in a list of Nats
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim sum-List (Π ([l (List Nat)])
                  Nat))
(define sum-List
  (λ (l)
    (rec-List l
              0
              (λ (n ns sum-List-ns)
                (plus n sum-List-ns)))))


(check-same Nat (sum-List (the (List Nat) (:: 2 (:: 3 (:: 0 (:: 1 nil)))))) 6)
(check-same Nat (sum-List (the (List Nat) nil)) 0)
(check-same Nat (sum-List (the (List Nat) (:: 0 nil))) 0)
(check-same Nat (sum-List (the (List Nat) (:: 0 (:: 1 (:: 20 (:: 1 (:: 5 (:: 5 (:: 3 (:: 6 (:: 0 (:: 1 nil)))))))))))) 42)


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 8
;; Define and test a function `maybe-last`, which given
;; a (List E) returns the last E in the list if one exists,
;; or some default E if the list is not long enough.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
TODO
#;
#;
(claim maybe-last (Π ([X U])
                    (-> (List X) X X)))
(define maybe-last
  (λ (X)
    (λ (l)
      (rec-List l
        (λ (default) default)
        (λ (x xs maybe-last-xs-else)
          (λ (default) (rec-List xs
                                 default
                                 (λ (xs-x xs-xs maybe-last-xs-xs)
                                   (maybe-last-xs-else xs-xs)))))))))


;(check-same Nat (maybe-last Nat nil 0) 0)
;(check-same Nat (maybe-last Nat (:: 42 nil)) 42)
;(check-same Nat (maybe-last Nat (:: 41 (:: 42 nil)) 0) 42)




;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 9
;; Define and test a function `how-many`, which given a
;; (List E) and a predicate function (-> E Bool), returns the
;; count (Nat) of how many elements of the list passed the
;; predicate (i.e. how many elements produced true when the
;; predicate was applied to them)
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim how-many (Π ([X U])
                  (-> (-> X Bool) (List X) Nat)))
(define how-many
  (λ (X p l) (rec-List l
             0
             (λ (x xs how-many-xs)
               (if Nat
                 (p x)
                 (add1 how-many-xs)
                 how-many-xs)))))


;; currying less-than actually gives you greater-than-blah
;; when you feed it one argument, FYI
(check-same Nat (how-many Nat (less-than 10)
                  (:: 0 (:: 1 (:: 10 (:: 11 nil)))))
  1)
(check-same Nat (how-many Nat (less-than 10)
                  (:: 0 (:: 1 (:: 11 (:: 12 nil)))))
  2)
(check-same Nat (how-many Nat (less-than 1)
                  (:: 0 (:: 0 (:: 0 nil))))
  0)
(check-same Nat (how-many Nat (less-than 0)
                  (:: 1 (:: 1 (:: 1 nil))))
  3)
(check-same Nat (how-many Nat (less-than 0)
                  (the (List Nat) nil))
  0)




;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 10
;; Define and test a function `vec-second` which takes
;; vector with at least two Es and returns the second E.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

(claim vec-second (Π ([X U]
                      [k Nat])
                    (-> (Vec X (add1 (add1 k))) X)))
(define vec-second
  (λ (X k)
    (λ (xs)
      (head (tail xs)))))



(check-same Nat
  (vec-second Nat 0 (vec:: 1 (vec:: 2 vecnil)))
  2)
(check-same Nat
  (vec-second Nat 3 (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 (vec:: 5 vecnil))))))
  2)






;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 11
;; Define and test a function `vec::::` which takes an E
;; and a (Vec E k) and returns a (Vec E (plus2 k))
;; (i.e. it adds two copies of the given E to the
;;       given vector of Es)
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;; This function (plus2) is defined for you to use in the type
;; of vec:::: -- USE THIS FUNCTION THERE AS INSTRUCTED!
(claim plus2 (-> Nat Nat))
(define plus2 (λ (n) (add 2 n)))

(claim vec:::: (Π ([E U]
                   [k Nat])
                 (-> E (Vec E k) (Vec E (plus2 k)))))
(define vec::::
  (λ (E k)
    (λ (e es)
      (vec:: e (vec:: e es)))))


(check-same (Vec Nat 3)
  (vec:::: Nat 1 42 (vec:: 0 vecnil))
  (vec:: 42 (vec:: 42 (vec:: 0 vecnil))))
(check-same (Vec Nat 2)
  (vec:::: Nat 0 42 vecnil)
  (vec:: 42 (vec:: 42 vecnil)))


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise 12
;; The definition of vec:::: seems to have a problem if we
;; define plus2 as follows (i.e. use plus instead of add):
;;
;; (define plus2 (λ (x) (plus 2 x))) ;; TRY IT NOW!
;;
;; What is the error message?
;;
;; What does that error message mean? Why are we seeing it?
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;error message:
;vec:: requires that the length have add1 on top, not (rec-Nat k (the Nat 2) (λ (i-1 add-i-1-n) (add1 add-i-1-n)))
;reason:
;in the case of add, we are eliminating over the first argument which means that we end
;with a (λ (m) ...add1's here(amount according to n)... m)
;in the case of plus, we are eliminating over the second argument which leads
;us to (λ (m) (rec-Nat ...whatever we passed as n... step))
;pie does not know that although it is obvious to us, rec-Nat may not be a Nat which is plus 2 of some other Nat
;add has add1's right after the λ





;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Challenge problems (i.e. not for credit -- just for "fun"!)
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *




;; Write a function that updates a specified index in a list
;; with a given update function, or returns the list unmodified
;; if the index is invalid.
;;
;; i.e. it should behave like Racket's list-update but it must
;; be total.



;; Write a function to sort a list of Nats.



;; Write a function `fold-left`, which given a
;; (List E) and a function (-> E X X) produces a X
;;
;; i.e. it should behave like Racket's foldl