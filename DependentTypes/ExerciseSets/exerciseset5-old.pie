#lang pie-a-let-mode

;; Note: This assignment requires the `pie-a-let-mode` package

;; Due Friday March 2nd
;; Submit the URL to your solutions on Canvas
;; before 5pm on the due date.

;; Note: Exercises (i.e. the stuff you have to do for the
;; assignment) are clearly labeled with `EXERICISE`. For
;; full credit on an exercise, there should not be any
;; TODOs left (excluding TODOs we have placed in the
;; `Prelude` section). Partial credit may be awarded if
;; you have made progress towards a solution but
;; could not complete it.


;; JACOB ADLEY


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Prelude
;;
;; Peruse and make sure you understand these definitions.
;; Any TODOs in this section can be IGNORED -- i.e. you're
;; allowed to assume them without proof and use them
;; in proofs in the remaining sections.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


(claim succ (-> Nat Nat))
(define succ (λ (x) (add1 x)))

(claim + (-> Nat Nat Nat))
(define + (λ (n m) (iter-Nat n m succ)))

(check-same Nat (+ 3 4) 7)

(claim * (-> Nat Nat Nat))
(define * (λ (n m) (iter-Nat n 0 (+ m))))

(check-same Nat (* 3 4) 12)


(claim +-zero-l
  (Π ([n Nat])
    (= Nat (+ 0 n) n)))
(define +-zero-l
  (λ (n)
    (same n)))

;; forall n ∈ Nat, (+ n 0) = n
(claim +-zero-r
  (Π ([n Nat])
    (= Nat (+ n 0) n)))
(define +-zero-r
  (λ (n)
    (ind-Nat n
      (λ (k)
        (= Nat (+ k 0) k))
      (same 0)
      (λ (k IH)
        (cong IH succ)))))

(claim +-add1-l
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ (add1 n) m)
       (add1 (+ n m)))))
(define +-add1-l
  (λ (n m)
    (same (add1 (+ n m)))))

;; ∀ n,m ∈ Nat. (+ n (add1 m)) = (add1 (+ n m))
(claim +-add1-r
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ n (add1 m))
       (add1 (+ n m)))))
(define +-add1-r
  (λ (n m)
    (ind-Nat n
      (λ (k) (= Nat (+ k (add1 m))
               (add1 (+ k m))))
      (same (add1 m))
      (λ (k-1 IH)
        (cong IH succ)))))

;;∀ x,y,z ∈ Nat. (+ x (+ y z)) = (+ (+ x y) z)
(claim +-assoc
  (Π ([x Nat]
      [y Nat]
      [z Nat])
    (= Nat
     (+ x (+ y z))
     (+ (+ x y) z))))
(define +-assoc
  (λ (x y z)
    (ind-Nat x
      (λ (k) (= Nat
               (+ k (+ y z))
               (+ (+ k y) z)))
      (same (+ y z))
      (λ (k-1 IH)
        (cong IH succ)))))


(claim +-comm
  (Π ([n Nat]
      [m Nat])
    (= Nat (+ n m) (+ m n))))
(define +-comm
  (λ (n m)
    (ind-Nat n
      (λ (k)
        (= Nat (+ k m) (+ m k)))
      (ind-Nat m
        (λ (k) (= Nat (+ 0 k) (+ k 0)))
        (same 0)
        (λ (k-1 IH)
          (cong IH succ)))
      (λ (k IH)
        (equal Nat
          (+ (add1 k) m)
          #:by (same (add1 (+ k m)))
          (add1 (+ k m))
          #:by (cong IH succ)
          (add1 (+ m k))
          #:by (symm (+-add1-r m k))
          (+ m (add1 k)))))))


;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; twice=double conversion
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

(claim twice
  (-> Nat Nat))
(define twice
  (λ (n) (+ n n)))


(claim double
  (-> Nat Nat))
(define double
  (λ (n) (iter-Nat n 0
           (λ (x) (add1 (add1 x))))))

;; EXERICISE
;; Convert the following proof (twice=double-ind-step1)
;; into a proof that does not use `equal` or `let`.
;; Try to make the proof as concise as possible.
(claim twice=double-ind-step
  (Π ([k Nat])
    (-> (= Nat
          (twice k)
          (double k))
      (= Nat
        (twice (add1 k))
        (double (add1 k))))))
#;
(define twice=double-ind-step
  (λ (k twicek=doublek)
    (equal Nat   
      (twice (add1 k))
      #:by (same (twice (add1 k)))
      (+ (add1 k) (add1 k))
      #:by (+-add1-r (add1 k) k)
      (add1 (+ (add1 k) k))
      #:by (same (add1 (+ (add1 k) k)))
      (add1 (add1 (+ k k)))
      #:by (same (add1 (add1 (+ k k))))
      (add1 (add1 (twice k)))
      #:by (cong twicek=doublek (+ 2))
      (add1 (add1 (double k)))
      #:by (same (add1 (add1 (double k))))
      (double (add1 k)))))

(define twice=double-ind-step
  (λ (k twicek=doublek)
    (trans (+-add1-r (add1 k) k) (cong twicek=doublek (+ 2)))))



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Thrice means three times.
;;
;; Hint: If for some term `x` you have a proof `x=y` that
;; says "x equals y", then both `cong` and `replace` can
;; be used to convert equality proofs which mention `x`
;; into equality proofs that instead mention `y`.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
(claim twice=double
  (Π ([n Nat])
    (= Nat
       (twice n)
       (double n))))
(define twice=double
  (λ (n)
    (ind-Nat n
      (λ (x) (= Nat
               (twice x)
               (double x)))
      (same 0)
      twice=double-ind-step)))

(claim thrice
  (-> Nat Nat))
(define thrice
  (λ (n) (+ n (+ n n))))


(claim triple
  (-> Nat Nat))
(define triple
  (λ (n)
    (iter-Nat n
      0
      (λ (x)
        (add1 (add1 (add1 x)))))))

;; EXERICISE
;; Finish the following proof:

(claim thrice=triple
  (Π ([n Nat])
    (= Nat
       (thrice n)
       (triple n))))
(define thrice=triple
  (λ (n)
    (ind-Nat n
      (λ (x) (= Nat
               (thrice x)
               (triple x)))
      (same 0)
      (λ (k thricek=triplek)
        (equal Nat
          (thrice (add1 k))
          #:by (same (thrice (add1 k)))
          (add1 (+ k (twice (add1 k))))
          #:by (cong (cong (twice=double (add1 k)) (+ k)) succ)
          (add1 (+ k (double (add1 k))))
          #:by (same (+ (add1 k) (double (add1 k))))
          (+ (add1 k) (double (add1 k)))
          #:by TODO;(cong (+-assoc k k k) succ) ;replace
          (triple (add1 k)))))))



;; EXERICISE
;; Convert your proof for `thrice=triple`
;; into a proof that does not use `equal`,
;; `let`, or `replace`.
(claim thrice=triple-v2
  (Π ([n Nat])
    (= Nat
       (thrice n)
       (triple n))))
(define thrice=triple-v2
  TODO)


;; EXERICISE
;; Convert your proof for `thrice=triple-v2`
;; into a proof that does not use `equal`,
;; `let`, or `cong`.
(claim thrice=triple-v3
  (Π ([n Nat])
    (= Nat
       (thrice n)
       (triple n))))
(define thrice=triple-v3
  TODO)



;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;; Arithmetic is fun!
;;
;; HINT 1: When trying to prove a theorem, remember that
;;         any previous definitions (i.e. proofs) may be
;;         used if/when they are helpful.
;; HINT 2: Sometimes you will need induction... but
;;         sometimes you will not! Don't force it.
;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *



;; EXERICISE
;; Prove this statement:
(claim *-0-l
  (Π ([n Nat])
    (= Nat (* 0 n) 0)))
(define *-0-l
  (λ (n)
    (same 0)))



;; EXERICISE
;; Prove this statement:
(claim *-0-r
  (Π ([n Nat])
    (= Nat (* n 0) 0)))
(define *-0-r
  (λ (n)
    (ind-Nat n
      (λ (c) (= Nat (* c 0) 0))
      (same 0)
      (λ (c-1 IH)
        IH))))



;; EXERICISE
;; Prove this statement:
(claim *-1-l
  (Π ([n Nat])
    (= Nat (* 1 n) n)))
(define *-1-l
  (λ (n)
    (ind-Nat n
      (λ (c) (= Nat (* 1 c) c))
      (same 0)
      (λ (c-1 IH)
        (cong IH succ)))))



;; EXERICISE
;; Prove this statement:
(claim *-1-r
  (Π ([n Nat])
    (= Nat (* n 1) n)))
(define *-1-r
  (λ (n)
    (*-1-l n)))


;; EXERICISE
;; Prove this statement:
(claim *-add1-l
  (Π ([a Nat]
      [b Nat])
    (= Nat
       (* (add1 a) b)
       (+ b (* a b)))))
(define *-add1-l
  (λ (a b)
    (same (* (add1 a) b))))



;; EXERICISE
;; Prove this statement:
(claim a+b+c=b+a+c
  (Π ([a Nat]
      [b Nat]
      [c Nat])
    (= Nat
     (+ a (+ b c))
     (+ b (+ a c)))))
(define a+b+c=b+a+c
  (λ (a b c)
    (ind-Nat a
      (λ (k) (= Nat
               (+ k (+ b c))
               (+ b (+ k c))))
      (same (+ b c))
      (λ (k-1 IH)
        (equal Nat
          (add1 (+ k-1 (+ b c)))
          #:by (cong (+-assoc k-1 b c) succ)
          (add1 (+ (+ k-1 b) c))
          #:by (cong (cong (+-comm k-1 b) (the (-> Nat Nat) (λ (x) (+ x c)))) succ) ;(replace (+-comm k-1 b) (λ (hole) (= Nat (add1 (+ (+ k-1 b) c)) (add1 (+ hole c)))) (cong (+-assoc k-1 b c) succ))
          (add1 (+ (+ b k-1) c))
          #:by (symm (cong (+-assoc b k-1 c) succ))
          (add1 (+ b (+ k-1 c)))
          #:by (symm (+-add1-r b (+ k-1 c)))
          (+ b (add1 (+ k-1 c))))))))


;; EXERICISE
;; Prove this statement:
(claim *-add1-r
  (Π ([a Nat]
      [b Nat])
    (= Nat
       (* a (add1 b))
       (+ a (* a b)))))
(define *-add1-r
  (λ (a b)
    TODO))



;; EXERICISE
;; Prove this statement:
(claim w+x+y+z=w+y+x+z
  (Π ([w Nat]
      [x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (+ (+ w x) (+ y z))
       (+ (+ w y) (+ x z)))))
(define w+x+y+z=w+y+x+z
  (λ (w x y z)
    (equal Nat
      (+ (+ w x) (+ y z))
      #:by (+-assoc (+ w x) y z)
      (+ (+ (+ w x) y) z)
      #:by (cong (symm (+-assoc w x y)) (the (-> Nat Nat) (λ (hole) (+ hole z))))
      (+ (+ w (+ x y)) z)
      #:by (cong (+-comm x y) (the (-> Nat Nat) (λ (hole) (+ (+ w hole) z))))
      (+ (+ w (+ y x)) z)
      #:by (cong (+-assoc w y x) (the (-> Nat Nat) (λ (hole) (+ hole z))))
      (+ (+ (+ w y) x) z)
      #:by (symm (+-assoc (+ w y) x z))
      (+ (+ w y) (+ x z)))))


;; EXERICISE
;; Prove this statement:
(claim *-distributes
  (Π ([l Nat]
      [m Nat]
      [n Nat])
    (= Nat
       (* l (+ m n))
       (+ (* l m) (* l n)))))
(define *-distributes
  TODO)




