#lang pie-a-let-mode

;; Jacob Adley

;; Note: This assignment requires the `pie-a-let-mode`
;; package (technically it would be possible to do it
;; without it... but that's not recommended)

;; Due Friday March 23rd
;; Submit the URL to your solutions on Canvas
;; before 5pm on the due date.

;                       
;                       
;  ;;   ;           ;   
;  ;;   ;           ;   
;  ;;;  ;  ;;;;   ;;;;; 
;  ; ;  ;      ;    ;   
;  ; ;; ;      ;    ;   
;  ;  ; ;   ;;;;    ;   
;  ;  ;;;  ;   ;    ;   
;  ;   ;;  ;   ;    ;   
;  ;   ;;   ;;;;    ;;; 
;                       
;                       
;                       

(claim succ (-> Nat Nat))
(define succ (λ (x) (add1 x)))

(claim + (-> Nat Nat Nat))
(define + (λ (x y) (iter-Nat x y succ)))

(claim * (-> Nat Nat Nat))
(define * (λ (x y) (iter-Nat x 0 (+ y))))

(claim +-zero-l
  (Π ([n Nat])
    (= Nat (+ 0 n) n)))
(define +-zero-l
  (λ (n) (same n)))

(claim +-zero-r
  (Π ([n Nat])
    (= Nat (+ n 0) n)))
(define +-zero-r
  (λ (n)
    (ind-Nat n
      (λ (?) (= Nat (+ ? 0) ?))
      (same 0)
      (λ (k IH)
        (cong IH succ)))))

(claim +-add1-l
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ (add1 n) m)
       (add1 (+ n m)))))
(define +-add1-l
  (λ (n m)
    (same (add1 (+ n m)))))

(claim +-add1-r
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ n (add1 m))
       (add1 (+ n m)))))
(define +-add1-r
  (λ (n m)
    (ind-Nat n
      (λ (?) (= Nat
               (+ ? (add1 m))
               (add1 (+ ? m))))
      (same (add1 m))
      (λ (k IH)
        (cong IH succ)))))

(claim +-assoc
  (Π ([x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (+ (+ x y) z)
       (+ x (+ y z)))))
(define +-assoc
  (λ (x y z)
    (ind-Nat x
      (λ (?) (= Nat
               (+ (+ ? y) z)
               (+ ? (+ y z))))
      (same (+ y z))
      (λ (k IH)
        (cong IH succ)))))


(claim +-comm
  (Π ([n Nat]
      [m Nat])
    (= Nat (+ n m) (+ m n))))
(define +-comm
  (λ (n m)
    (ind-Nat n
      (λ (?) (= Nat (+ ? m) (+ m ?)))
      (symm (+-zero-r m))
      (λ (k IH)
        (equal Nat
          (add1 (+ k m))
          #:by (cong IH succ)
          (add1 (+ m k))
          #:by (symm (+-add1-r m k))
          (+ m (add1 k)))))))

(claim a+b+c=b+a+c
  (Π ([a Nat]
      [b Nat]
      [c Nat])
    (= Nat
       (+ a (+ b c))
       (+ b (+ a c)))))
(define a+b+c=b+a+c
  (λ (a b c)
    (equal Nat
      (+ a (+ b c))
      #:by (symm (+-assoc a b c))
      (+ (+ a b) c)
      #:by (cong (+-comm a b)
             (the (-> Nat Nat)
               (λ (x) (+ x c))))
      (+ (+ b a) c)
      #:by (+-assoc b a c)
      (+ b (+ a c)))))

(claim rotate+
  (Π ([w Nat]
      [x Nat]
      [y Nat]
      [z Nat])
    (= Nat
       (+ (+ w x) (+ y z))
       (+ (+ w y) (+ x z)))))
(define rotate+
  (λ (w x y z)
    (equal Nat
      (+ (+ w x) (+ y z))
      #:by (a+b+c=b+a+c (+ w x) y z)
      (+ y (+ (+ w x) z))
      #:by (cong (+-comm (+ w x) z) (+ y))
      (+ y (+ z (+ w x)))
      #:by (cong (a+b+c=b+a+c z w x) (+ y))
      (+ y (+ w (+ z x)))
      #:by (a+b+c=b+a+c y w (+ z x))
      (+ w (+ y (+ z x)))
      #:by (cong (+-comm z x)
             (the (-> Nat Nat)
               (λ (x) (+ w (+ y x)))))
      (+ w (+ y (+ x z)))
      #:by (symm (+-assoc w y (+ x z)))
      (+ (+ w y) (+ x z)))))

(claim *-distributes
  (Π ([l Nat]
      [m Nat]
      [n Nat])
    (= Nat
       (* l (+ m n))
       (+ (* l m) (* l n)))))
(define *-distributes
  (λ (l m n)
    (ind-Nat l
      (λ (x) (= Nat
               (* x (+ m n))
               (+ (* x m) (* x n))))
      (same 0)
      (λ (k almostProof)
        (let ([IH (the (= Nat
                         (* k (+ m n))
                         (+ (* k m) (* k n)))
                    almostProof)])
          (equal Nat
                 (* (add1 k) (+ m n))
                 #:by (same (+ (+ m n) (* k (+ m n))))
                 (+ (+ m n) (* k (+ m n)))
                 #:by (cong IH (+ (+ m n)))
                 (+ (+ m n) (+ (* k m) (* k n)))
                 #:by (rotate+ m n (* k m) (* k n))
                 (+ (+ m (* k m)) (+ n (* k n)))
                 #:by (same (+ (* (add1 k) m) (* (add1 k) n)))
                 (+ (* (add1 k) m) (* (add1 k) n))))))))

(claim *-zero-l
  (Π ([n Nat])
    (= Nat (* 0 n) 0)))
(define *-zero-l
  (λ (n) (same 0)))

(claim *-zero-r
  (Π ([n Nat])
    (= Nat (* n 0) 0)))
(define *-zero-r
  (λ (n)
    (ind-Nat n
      (λ (?) (= Nat (* ? 0) 0))
      (same 0)
      (λ (k IH)
        (equal Nat
          (* (add1 k) 0)
          #:by (same (* (add1 k) 0))
          (* k 0)
          #:by IH
          0)))))



;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove *-add1-r by replacing the TODO with
;; a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim *-add1-r
  (Π ([j Nat]
      [k Nat])
    (= Nat
       (+ j (* j k))
       (* j (add1 k)))))
(define *-add1-r
  (λ (j k)
    (ind-Nat j
      (λ (x) (= Nat
               (+ x (* x k))
               (* x (add1 k))))
      (same 0)
      (λ (x IH)
        (equal Nat
          (+ (add1 x) (* (add1 x) k))
          #:by (same (add1 (+ x (* (add1 x) k))))
          (add1 (+ x (* (add1 x) k)))
          #:by (same (add1 (+ x (+ k (* x k)))))
          (add1 (+ x (+ k (* x k))))
          #:by (cong (a+b+c=b+a+c x k (* x k)) succ)
          (add1 (+ k (+ x (* x k))))
          #:by (cong IH (the (-> Nat Nat) (λ (?) (add1 (+ k ?)))))
          #;
          (replace IH
            (λ (?) (= Nat
                     (add1 (+ k (+ x (* x k))))
                     (add1 (+ k ?))))
            (same (add1 (+ k (+ x (* x k))))))
          (add1 (+ k (* x (add1 k))))
          #:by (same (+ (add1 k) (* x (add1 k))))
          (+ (add1 k) (* x (add1 k)))
          #:by (same (* (add1 x) (add1 k)))
          (* (add1 x) (add1 k)))))))


;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove *-comm by replacing the TODO with
;; a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim *-comm
  (Π ([n Nat]
      [m Nat])
    (= Nat (* n m) (* m n))))
(define *-comm
  (λ (n m)
    (ind-Nat n
      (λ (x) (= Nat (* x m) (* m x)))
      (symm (*-zero-r m))
      (λ (x IH)
        (equal Nat
          (* (add1 x) m)
          #:by (same (+ m (* x m)))
          (+ m (* x m))
          #:by (cong IH (+ m))
          (+ m (* m x))
          #:by (*-add1-r m x)
          (* m (add1 x)))))))

;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove *-assoc by replacing the TODO with
;; a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim *-assoc
  (Π ([i Nat]
      [j Nat]
      [k Nat])
    (= Nat (* i (* j k)) (* (* i j) k))))
(define *-assoc
  (λ (i j k)
    (ind-Nat i
      (λ (x) (= Nat (* x (* j k)) (* (* x j) k)))
      (same 0)
      (λ (x IH)
        (equal Nat
          (* (add1 x) (* j k))
          #:by (same (+ (* j k) (* x (* j k))))
          (+ (* j k) (* x (* j k)))
          #:by (cong IH (+ (* j k)))
          (+ (* j k) (* (* x j) k))
          #:by (cong (*-comm j k) (the (-> Nat Nat) (λ (?) (+ ? (* (* x j) k)))))
          (+ (* k j) (* (* x j) k))
          #:by (cong (*-comm (* x j) k) (the (-> Nat Nat) (λ (?) (+ (* k j) ?))))
          (+ (* k j) (* k (* x j)))
          #:by (symm (*-distributes k j (* x j)))
          (* k (+ j (* x j)))
          #:by (*-comm k (+ j (* x j)))
          (* (+ j (* x j)) k)
          #:by (same (* (* (add1 x) j) k))
          (* (* (add1 x) j) k))))))



;                              
;                              
;   ;         ;            ;   
;   ;                      ;   
;   ;       ;;;    ;;;   ;;;;; 
;   ;         ;   ;   ;    ;   
;   ;         ;   ;        ;   
;   ;         ;    ;;;     ;   
;   ;         ;       ;    ;   
;   ;         ;   ;   ;    ;   
;   ;;;;;;  ;;;;;  ;;;     ;;; 
;                              
;                              
;                              

(claim list-app
  (Π ([E U])
    (-> (List E) (List E)
      (List E))))
(define list-app
  (λ (E l1 l2)
    (rec-List l1
      l2
      (λ (e es es++l2)
        (:: e es++l2)))))




(claim list-map
  (Π ([A U]
      [B U])
    (-> (-> A B) (List A)
      (List B))))
(define list-map
  (λ (A B)
    (λ (f es)
      (rec-List es
        (the (List B) nil)
        (λ (x xs map-of-xs)
          (:: (f x) map-of-xs))))))


;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove list-app-map-app by replacing the TODO
;; with a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim list-app-map-app
  (Π ([X U]
      [Y U]
      [f (-> X Y)]
      [l1 (List X)]
      [l2 (List X)])
    (= (List Y)
       (list-app Y (list-map X Y f l1) (list-map X Y f l2))
       (list-map X Y f (list-app X l1 l2)))))
(define list-app-map-app
  (λ (X Y)
    (λ (f)
      (λ (l1 l2)
        (ind-List l1
          (λ (l) (= (List Y)
                   (list-app Y (list-map X Y f l) (list-map X Y f l2))
                   (list-map X Y f (list-app X l l2))))
          (same (list-map X Y f l2))
          (λ (x xs IH)
            (equal (List Y)
              (list-app Y (list-map X Y f (:: x xs)) (list-map X Y f l2))
              #:by (same (list-app Y (:: (f x) (list-map X Y f xs)) (list-map X Y f l2)))
              (list-app Y (:: (f x) (list-map X Y f xs)) (list-map X Y f l2))
              #:by (same (:: (f x) (list-app Y (list-map X Y f xs) (list-map X Y f l2))))
              (:: (f x) (list-app Y (list-map X Y f xs) (list-map X Y f l2)))
              #:by (cong IH (the (-> (List Y) (List Y)) (λ (?) (:: (f x) ?))))
              (:: (f x) (list-map X Y f (list-app X xs l2)))
              #:by (same (list-map X Y f (list-app X (:: x xs) l2)))
              (list-map X Y f (list-app X (:: x xs) l2)))))))))



;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove list-app-assoc by replacing the TODO
;; with a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim list-app-assoc
  (Π ([E U]
      [l1 (List E)]
      [l2 (List E)]
      [l3 (List E)])
    (= (List E)
       (list-app E l1 (list-app E l2 l3))
       (list-app E (list-app E l1 l2) l3))))
(define list-app-assoc
  (λ (E)
    (λ (l1 l2 l3)
      (ind-List l1
        (λ (l) (= (List E)
                 (list-app E l (list-app E l2 l3))
                 (list-app E (list-app E l l2) l3)))
        (same (list-app E l2 l3))
        (λ (e es IH)
          (equal (List E)
            (list-app E (:: e es) (list-app E l2 l3))
            #:by (same (:: e (list-app E es (list-app E l2 l3))))
            (:: e (list-app E es (list-app E l2 l3)))
            #:by (replace IH
                   (λ (?) (= (List E)
                            (:: e (list-app E es (list-app E l2 l3)))
                            (:: e ?)))
                   (same (:: e (list-app E es (list-app E l2 l3)))))
            (:: e (list-app E (list-app E es l2) l3))
            #:by (same (list-app E (:: e (list-app E es l2)) l3))
            (list-app E (:: e (list-app E es l2)) l3)
            #:by (same (list-app E (list-app E (:: e es) l2) l3))
            (list-app E (list-app E (:: e es) l2) l3)))))))

;(list-app E es (list-app E l2 l3))
;#:by IH
;(list-app E (list-app E es l2) l3)


;                                     
;                                     
;    ;;;;     ;                       
;   ;;   ;                            
;   ;       ;;;    ;;;; ;;;;;;  ;;;;  
;   ;;        ;   ;;  ; ;  ;  ;     ; 
;    ;;;;     ;   ;   ; ;  ;  ;     ; 
;        ;    ;   ;   ; ;  ;  ;  ;;;; 
;        ;    ;   ;   ; ;  ;  ; ;   ; 
;   ;    ;    ;   ;; ;; ;  ;  ; ;   ; 
;    ;;;;   ;;;;;  ;;;; ;  ;  ;  ;;;; 
;                     ;               
;                  ;  ;               
;                   ;;                




(claim double
  (-> Nat Nat))
(define double
  (λ (n)
    (iter-Nat n 0 (+ 2))))

(claim Even (-> Nat U))
(define Even
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (double k)))))

(claim Odd (-> Nat U))
(define Odd
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (add1 (double k))))))



;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove even+even=even by replacing the TODO
;; with a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim dbl-distr
  (Π ([n Nat]
      [m Nat])
    (= Nat
       (+ (double n) (double m))
       (double (+ n m)))))
(define dbl-distr
  (λ (n m)
    (ind-Nat n
      (λ (x) (= Nat
               (+ (double x) (double m))
               (double (+ x m))))
      (same (double m))
      (λ (x IH)
        (cong IH (+ 2))))))

(claim even+even=even
  (Π ([n Nat]
      [m Nat]
      [n-even (Even n)]
      [m-even (Even m)])
    (Even (+ n m))))
(define even+even=even
  (λ (n m)
    (λ (n-even m-even)
      (let ([n/2 (car n-even)]
            [n=dbl-n/2 (the (= Nat n (double n/2))
                         (cdr n-even))]
            [m/2 (car m-even)]
            [m=dbl-m/2 (the (= Nat m (double m/2))
                         (cdr m-even))])
        (cons
         (+ n/2 m/2)
         (equal Nat
           (+ n m)
           #:by (replace n=dbl-n/2
                  (λ (?) (= Nat
                           (+ n m)
                           (+ ? m)))
                  (same (+ n m)))
           (+ (double n/2) m)
           #:by (replace m=dbl-m/2
                  (λ (?) (= Nat
                           (+ (double n/2) m)
                           (+ (double n/2) ?)))
                  (same (+ (double n/2) m)))
           (+ (double n/2) (double m/2))
           #:by (dbl-distr n/2 m/2)
           (double (+ n/2 m/2))))))))


;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Define Square as a type describing a
;; perfect square number (hint: use Sigma).
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim Square (-> Nat U))
(define Square
  (λ (n)
    (Σ ([k Nat])
      (= Nat n (* k k)))))


;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Claim and prove that 9 is a perfect square.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim 9-square (Square 9))
(define 9-square
  (cons 3 (same 9)))


;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Claim and prove that 36 is a perfect square.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim 36-square (Square 36))
(define 36-square
  (cons 6 (same 36)))


;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Claim and prove that if x and y are perfect
;; squares, then (* x y) is a perfect square.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim prod-square-square
  (Π ([x Nat]
      [y Nat]
      [x-perf (Square x)]
      [y-perf (Square y)])
    (Square (* x y))))
(define prod-square-square
  (λ (x y)
    (λ (x-perf y-perf)
      (let ([root-x (car x-perf)]
            [x=sqr-root-x (the (= Nat x (* root-x root-x))
                            (cdr x-perf))]
            [root-y (car y-perf)]
            [y=sqr-root-y (the (= Nat y (* root-y root-y))
                            (cdr y-perf))])
        (cons
         (* root-x root-y)
         (equal Nat
           (* x y)
           #:by (replace x=sqr-root-x
                  (λ (?) (= Nat
                           (* x y)
                           (* ? y)))
                  (same (* x y)))
           (* (* root-x root-x) y)
           #:by (replace y=sqr-root-y
                  (λ (?) (= Nat
                           (* (* root-x root-x) y)
                           (* (* root-x root-x) ?)))
                  (same (* (* root-x root-x) y)))
           (* (* root-x root-x) (* root-y root-y))
           #:by (*-assoc (* root-x root-x) root-y root-y)
           (* (* (* root-x root-x) root-y) root-y)
           #:by (replace (*-comm (* root-x root-x) root-y)
                  (λ (?) (= Nat
                           (* (* (* root-x root-x) root-y) root-y)
                           (* ? root-y)))
                  (same (* (* (* root-x root-x) root-y) root-y)))
           (* (* root-y (* root-x root-x)) root-y)
           #:by (replace (*-assoc root-y root-x root-x)
                  (λ (?) (= Nat
                           (* (* root-y (* root-x root-x)) root-y)
                           (* ? root-y)))
                  (same (* (* root-y (* root-x root-x)) root-y)))
           (* (* (* root-y root-x) root-x) root-y)
           #:by (replace (*-comm root-y root-x)
                  (λ (?) (= Nat
                           (* (* (* root-y root-x) root-x) root-y)
                           (* (* ? root-x) root-y)))
                  (same (* (* (* root-y root-x) root-x) root-y)))
           (* (* (* root-x root-y) root-x) root-y)
           #:by (symm (*-assoc (* root-x root-y) root-x root-y))
           (* (* root-x root-y) (* root-x root-y))))))))





;                       
;                       
;   ;    ;              
;   ;    ;              
;    ;  ;   ;;;    ;;;  
;    ;  ;  ;;  ;  ;;  ; 
;    ;  ;  ;   ;; ;     
;    ;  ;  ;;;;;; ;     
;     ;;   ;      ;     
;     ;;   ;      ;;    
;     ;;    ;;;;   ;;;; 
;                       
;                       
;                       


(claim vec-app
  (Π ([E U]
      [n Nat]
      [m Nat])
    (-> (Vec E n) (Vec E m)
      (Vec E (+ n m)))))
(define vec-app
  (λ (E n m xs ys)
    (ind-Vec n xs
      (λ (?n ?v) (Vec E (+ ?n m)))
      ys
      (λ (k h t t++ys)
        (vec:: h t++ys)))))


(claim vec-map
  (Π ((A U)
      (B U)
      [n Nat])
    (-> (-> A B)
        (Vec A n)
      (Vec B n))))
(define vec-map
  (λ (A B n f v)
    (ind-Vec n v
      (λ (n v) (Vec B n))
      vecnil
      (λ (k x xs map-of-xs)
        (vec:: (f x) map-of-xs)))))



;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Prove vec-app-map-vec-app by replacing the TODO
;; with a program of the correct type.
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim vec-app-map-vec-app
  (Π ((X U)
      (Y U)
      (f (-> X Y))
      (j Nat)
      (k Nat)
      (front (Vec X j))
      (back (Vec X k)))
    (= (Vec Y (+ j k))
       (vec-app Y j k (vec-map X Y j f front) (vec-map X Y k f back))
       (vec-map X Y (+ j k) f (vec-app X j k front back)))))
(define vec-app-map-vec-app
  (λ (X Y f j k front back)
    (ind-Vec j front
      (λ (c xs) (= (Vec Y (+ c k))
                     (vec-app Y c k (vec-map X Y c f xs) (vec-map X Y k f back))
                     (vec-map X Y (+ c k) f (vec-app X c k xs back))))
      (same (vec-map X Y k f back))
      (λ (c x xs IH)
        (let ([IH (the (= (Vec Y (+ c k))
                         (vec-app Y c k (vec-map X Y c f xs) (vec-map X Y k f back))
                         (vec-map X Y (+ c k) f (vec-app X c k xs back)))
                    IH)])
          (equal (Vec Y (+ (add1 c) k))
                 (vec-app Y (add1 c) k (vec-map X Y (add1 c) f (vec:: x xs)) (vec-map X Y k f back))
                 #:by (same (vec-app Y (add1 c) k (vec:: (f x) (vec-map X Y c f xs)) (vec-map X Y k f back)))
                 (vec-app Y (add1 c) k (vec:: (f x) (vec-map X Y c f xs)) (vec-map X Y k f back))
                 #:by (same (vec:: (f x) (vec-app Y c k (vec-map X Y c f xs) (vec-map X Y k f back))))
                 (vec:: (f x) (vec-app Y c k (vec-map X Y c f xs) (vec-map X Y k f back)))
                 #:by (replace IH
                        (λ (?) (= (Vec Y (+ (add1 c) k))
                                 (vec:: (f x) (vec-app Y c k (vec-map X Y c f xs) (vec-map X Y k f back)))
                                 (vec:: (f x) ?)))
                        (same (vec:: (f x) (vec-app Y c k (vec-map X Y c f xs) (vec-map X Y k f back)))))
                 (vec:: (f x) (vec-map X Y (+ c k) f (vec-app X c k xs back)))
                 #:by (same (vec:: (f x) (vec-map X Y (+ c k) f (vec-app X c k xs back))))
                 (vec:: (f x) (vec-map X Y (+ c k) f (vec-app X c k xs back)))
                 #:by (same (vec-map X Y (add1 (+ c k)) f (vec:: x (vec-app X c k xs back))))
                 (vec-map X Y (add1 (+ c k)) f (vec:: x (vec-app X c k xs back)))
                 #:by (same (vec-map X Y (+ (add1 c) k) f (vec:: x (vec-app X c k xs back))))
                 (vec-map X Y (+ (add1 c) k) f (vec:: x (vec-app X c k xs back)))
                 #:by (same (vec-map X Y (+ (add1 c) k) f (vec-app X (add1 c) k (vec:: x xs) back)))
                 (vec-map X Y (+ (add1 c) k) f (vec-app X (add1 c) k (vec:: x xs) back))))))))



;; * * * * * * * * * * * * * * * * * * * * * * * *
;; Exercise
;; Claim and prove that appending vectors (vec-app)
;; is an associative operation,
;; i.e. v1 ++ (v2 ++ v3) = (v1 ++ v2) ++ v3
;; (where '++' means appending vectors)
;; * * * * * * * * * * * * * * * * * * * * * * * *
(claim replace=lemma
  (Π ([E U]
      [j Nat]
      [k Nat]
      [j=k (= Nat j k)]
      [e E]
      [es (Vec E j)]) 
    (= (Vec E (add1 k))
       (vec:: e (replace j=k
                  (λ (?) (Vec E ?))
                  es))
       (replace (cong j=k succ)
         (λ (?) (Vec E ?))
         (vec:: e es)))))
(define replace=lemma
  (λ (E j k j=k e es)
    (ind-= j=k
      (λ (k j=k) (= (Vec E (add1 k))
                   (vec:: e (replace j=k
                              (λ (?) (Vec E ?))
                              es))
                   (replace (cong j=k succ)
                     (λ (?) (Vec E ?))
                     (vec:: e es))))
      (same (vec:: e es)))))

(claim vec-app-assoc
  (Π ([E U]
      [i Nat]
      [j Nat]
      [k Nat]
      [v1 (Vec E i)]
      [v2 (Vec E j)]
      [v3 (Vec E k)])
    (= (Vec E (+ i (+ j k)))
       (vec-app E i (+ j k) v1 (vec-app E j k v2 v3))
       (replace (+-assoc i j k)
         (λ (?) (Vec E ?))
         (vec-app E (+ i j) k (vec-app E i j v1 v2) v3)))))
(define vec-app-assoc
  (λ (E i j k v1 v2 v3)
    (ind-Vec i v1
      (λ (c es) (= (Vec E (+ c (+ j k)))
                  (vec-app E c (+ j k) es (vec-app E j k v2 v3))
                  (replace (+-assoc c j k)
                    (λ (?) (Vec E ?))
                    (vec-app E (+ c j) k (vec-app E c j es v2) v3))))
      (same (vec-app E j k v2 v3))
      (λ (c e es IH)
        (let ([IH (the (= (Vec E (+ c (+ j k)))
                         (vec-app E c (+ j k) es (vec-app E j k v2 v3))
                         (replace (+-assoc c j k)
                           (λ (?) (Vec E ?))
                           (vec-app E (+ c j) k (vec-app E c j es v2) v3)))
                    IH)])
          (equal (Vec E (+ (add1 c) (+ j k)))
                 (vec-app E (add1 c) (+ j k) (vec:: e es) (vec-app E j k v2 v3))
                 #:by (same (vec:: e (vec-app E c (+ j k) es (vec-app E j k v2 v3))))
                 (vec:: e (vec-app E c (+ j k) es (vec-app E j k v2 v3)))
                 #:by (replace IH
                        (λ (?) (= (Vec E (+ (add1 c) (+ j k)))
                                 (vec:: e (vec-app E c (+ j k) es (vec-app E j k v2 v3)))
                                 (vec:: e ?)))
                        (same (vec:: e (vec-app E c (+ j k) es (vec-app E j k v2 v3)))))
                 (vec:: e
                   (replace (+-assoc c j k)
                     (λ (?) (Vec E ?))
                     (vec-app E (+ c j) k (vec-app E c j es v2) v3)))
                 #:by (replace=lemma E (+ (+ c j) k) (+ c (+ j k)) (+-assoc c j k) e (vec-app E (+ c j) k (vec-app E c j es v2) v3))
                 (replace (cong (+-assoc c j k) succ)
                   (λ (?) (Vec E ?))
                   (vec:: e (vec-app E (+ c j) k (vec-app E c j es v2) v3)))
                 #:by (same (replace (+-assoc (add1 c) j k)
                              (λ (?) (Vec E ?))
                              (vec:: e (vec-app E (+ c j) k (vec-app E c j es v2) v3))))
                 (replace (+-assoc (add1 c) j k)
                   (λ (?) (Vec E ?))
                   (vec:: e (vec-app E (+ c j) k (vec-app E c j es v2) v3)))
                 #:by (same (replace (+-assoc (add1 c) j k)
                              (λ (?) (Vec E ?))
                              (vec-app E (add1 (+ c j)) k (vec:: e (vec-app E c j es v2)) v3)))
                 (replace (+-assoc (add1 c) j k)
                   (λ (?) (Vec E ?))
                   (vec-app E (add1 (+ c j)) k (vec:: e (vec-app E c j es v2)) v3))
                 #:by (same (replace (+-assoc (add1 c) j k)
                              (λ (?) (Vec E ?))
                              (vec-app E (+ (add1 c) j) k (vec:: e (vec-app E c j es v2)) v3)))
                 (replace (+-assoc (add1 c) j k)
                   (λ (?) (Vec E ?))
                   (vec-app E (+ (add1 c) j) k (vec:: e (vec-app E c j es v2)) v3))
                 #:by (same (replace (+-assoc (add1 c) j k)
                              (λ (?) (Vec E ?))
                              (vec-app E (+ (add1 c) j) k (vec-app E (add1 c) j (vec:: e es) v2) v3)))
                 (replace (+-assoc (add1 c) j k)
                   (λ (?) (Vec E ?))
                   (vec-app E (+ (add1 c) j) k (vec-app E (add1 c) j (vec:: e es) v2) v3))))))))

