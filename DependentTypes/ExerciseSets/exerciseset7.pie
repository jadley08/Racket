#lang pie-a-let-mode

;; Exercise Set 7
;; Due April 20th


;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 1
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Prove that if (add1 n) and (add1 j) are equal then
;; n and j are equal (i.e. fill in the TODO for pred=).
(claim pred=
  (Π ([n Nat]
      [j Nat])
    (-> (= Nat (add1 n) (add1 j))
      (= Nat n j))))
(define pred=
  (λ (n j 1+n=1+j)
    (cong 1+n=1+j (the (-> Nat Nat)
                    (λ (k)
                      (which-Nat k
                        0
                        (λ (k-1)
                          k-1)))))))


;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 2
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Assuming that (= (List E) l1 l2), what do we
;; know in the various cases for l1 and l2? You may
;; fill in the below table directly, or briefly
;; explain what we can conclude in each quadrant
;; below the table in prose.
;;
;; ---------------------------------------------------
;;|               |             l2                    |
;;|               |                                   |
;;|               |   nil        |     (:: x xs)      |
;;|---------------------------------------------------|
;;|               |              |                    |
;;|           nil |   Trivial    |      Absurd        |
;;|               |              |                    |
;;|l1   ----------|--------------|--------------------|
;;|               |              |                    |
;;|               |              |                    |
;;|    (:: y ys)  |   Absurd     | (= (List E) ys xs) |
;;|               |              |                    |
;;|               |              |                    |
;;|----------------------------------------------------






;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 3
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Convert your answers from exercise 2 into a function
;; list=-consequence (i.e. this should resemble =consequence
;; from Chapter 15, except that it is about lists instead
;; of Nats)
(claim list=-consequence
  (Π ([E U])
    (-> (List E) (List E)
      U)))
(define list=-consequence
  (λ (E l1 l2)
    (rec-List l1
      (rec-List l2
        Trivial
        (λ (x xs _) Absurd))
      (λ (y ys _)
        (rec-List l2
          Absurd
          (λ (x xs _)
            (Pair (= E y x)
              (= (List E) ys xs))))))))



;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 4
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Show that the consequences are true when it's the same
;; list, as was done for Nats in Chapter 15.
(claim list=-same
  (Π ([E U]
      [l (List E)])
    (list=-consequence E l l)))
(define list=-same
  (λ (E l)
    (ind-List l
      (λ (?) (list=-consequence E ? ?))
      sole
      (λ (x xs IH)
        (cons
          (same x)
          (same xs))))))




;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 5
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Show that the consequences of equality hold for any two
;; equal lists. In other words, show that you can use the
;; fact that two lists are equal to find the consequences.
(claim use-list=
  (Π ([E U]
      [l1 (List E)]
      [l2 (List E)])
    (-> (= (List E) l1 l2)
      (list=-consequence E l1 l2))))
(define use-list=
  (λ (E l1 l2 l1=l2)
    (replace l1=l2
      (λ (?) (list=-consequence E l1 ?))
      (list=-same E l1))))






;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 6
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Prove that cons-ing equal elements onto equal lists
;; produces an equal result.
(claim ::=
  (Π ([E U]
      [x E]
      [y E]
      [xs (List E)]
      [ys (List E)])
    (-> (= E x y) (= (List E) xs ys)
      (= (List E) (:: x xs) (:: y ys)))))
(define ::=
  (λ (E x y xs ys)
    (λ (x=y xs=ys)
      (equal (List E)
        (:: x xs)
        #:by (replace xs=ys
               (λ (?) (= (List E)
                        (:: x xs)
                        (:: x ?)))
               (same (:: x xs)))
        (:: x ys)
        #:by (replace x=y
               (λ (?) (= (List E)
                        (:: x ys)
                        (:: ? ys)))
               (same (:: x ys)))
        (:: y ys)))))




;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Exercise 7
;; - - - - - - - - - - - - - - - - - - - - - - - - - - -
;; Prove that list equality is decidable.

(claim Dec
  (-> U U))
(define Dec
  (λ (X) (Either X (-> X Absurd))))

(claim list=?
  (Π ([E U]
      [e=? (Π ([e1 E]
               [e2 E])
             (Dec (= E e1 e2)))]
      [es1 (List E)]
      [es2 (List E)])
    (Dec (= (List E) es1 es2))))
(define list=?
  (λ (E e=? es1)
    (ind-List es1
      (λ (?) (Π ([es2 (List E)])
               (Dec (= (List E) ? es2))))
      (λ (es2)
        (ind-List es2
          (λ (?) (Dec (= (List E) nil ?)))
          (left (same nil))
          (λ (e es IH)
            (right (λ (nil=e::es)
                     (use-list= E nil (:: e es) nil=e::es))))))
      (λ (e es es=?)
        (λ (es2)
          (ind-List es2
            (λ (?) (Dec (= (List E) (:: e es) ?)))
            (right (λ (e::es=nil)
                     (use-list= E nil (:: e es) (symm e::es=nil))))
            (λ (k ks IH)
              (let ([es=ks? (es=? ks)])
                (ind-Either es=ks?
                  (λ (_) (Dec (= (List E) (:: e es) (:: k ks))))
                  (λ (es=ks) (ind-Either (e=? e k)
                               (λ (_) (Dec (= (List E) (:: e es) (:: k ks))))
                               (λ (e=k) (left
                                          (::= E e k es ks e=k es=ks)))
                               (λ (e!=k) (right
                                           (λ (e::es=k::ks)
                                             (e!=k (car (use-list= E (:: e es) (:: k ks) e::es=k::ks))))))))
                  (λ (es!=ks) (right (λ (e::es=k::ks)
                                       (es!=ks
                                         (cdr (use-list= E (:: e es) (:: k ks) e::es=k::ks)))))))))))))))

