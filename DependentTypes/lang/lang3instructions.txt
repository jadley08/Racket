- - - - - - - - - - - - -
Assignment `lang3`

Due by 3pm on 22 February
- - - - - - - - - - - - -


This assignment more-or-less extends your `lang2` interpreter by
adding bidirectional type checking and lists.

You are welcome to remove `which-Nat` and `iter-Nat` from your
interpreter if you wish, i.e. you may want to start with the
following grammar of types and expressions:

;; Type ::= Nat | (-> Type Type)
;;
;; Expr ::= Id
;;        | (the Type Expr)
;;        | (λ (Id) Expr)
;;        | (Expr Expr)
;;        | zero
;;        | (add1 Expr)
;;        | (rec-Nat Expr Expr Expr)

and then for part 2 you can add the List type and
introduction/elimination forms for lists.

[Part 1] (90%) Create a file `lang3.rkt` that is your `lang2`
   interpreter but which has a bidirectional type checker that ensures
   each expression in a program is well typed before evaluating it.

   The bidirectional type checker should mirror the logical rules for
   checking and synthesizing types that we discussed in class (see
   also the handout on the topic), i.e. you should

     a. Define a function `check` which. when given a context Γ, and
     expression e, and a type t, checks that e is a t in context Γ.
     If e is not a t in context Γ, a reasonable error of some sort
     should be returned in a way that allows for easy testing (a type
     checker which doesn't tell you what went wrong where would
     probably be pretty useless in practice).

     b. Define a function `synth` which, when given a context Γ and
     expression e, synthesizes a type for e if possible. When a type
     cannot be synthesized, a reasonable error of some sort should
     be returned in a way that allows for easy testing.

     c. Extend your definition of what a "program" is (i.e. the input
     to `valof-program`) to include top level "claim" statements that
     assign a type to an identifier before the definition of that
     identifier appears in the program (like we do in Pie). These
     predicates may be a useful place to start:

;; BEGIN CODE BLOCK

(define/spec (type? e)
  (-> any boolean?)
  (match e
    ['Nat #t]
    [`(-> ,t1 ,t2)
     (and (type? t1) (type? t2))]
    [_ #f]))

(define/spec (claim? e)
  (-> any boolean?)
  (match e
    [`(claim ,(? var?) ,(? type?)) #t]
    [_ #f]))

(define/spec (define? e)
  (-> any boolean?)
  (match e
    [`(define ,(? var?) ,(? expr?)) #t]
    [_ #f]))

;; a program is a list of defines and/or exprs
(define/spec (program? p)
  (-> any boolean?)
  (match p
    [(list (or (? expr?) (? define?) (? claim?)) ...) #t]
    [_ #f]))


;; END CODE BLOCK



  Write enough tests so that you (and the graders) are confident
  your bidirectional type checker works correctly on each form
  in the language.




[Part 2] (10%) Add lists to your interpreter and bidirectional type
   checker. Hint: the handout explains how elimination forms should be
   handled with respect to checking/synthesis. Use those descriptions
   as a guide.
   


NOTE: although the general rule for introduction forms is to handle
them in `check` mode, for extremely simple types such as `Nat`
handling those in synthesis mode instead (as Pie does) will be
desirable. For more complex introduction forms, an expected type
(i.e. using check mode) is more important.

